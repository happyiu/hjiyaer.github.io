<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咦~被你发现咯</title>
  
  <subtitle>嘻嘻</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.hjiya.cn/"/>
  <updated>2020-03-30T03:33:52.875Z</updated>
  <id>http://blog.hjiya.cn/</id>
  
  <author>
    <name>ERYORE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序云开发</title>
    <link href="http://blog.hjiya.cn/2020/03/30/wxxcxcloud/"/>
    <id>http://blog.hjiya.cn/2020/03/30/wxxcxcloud/</id>
    <published>2020-03-30T03:31:18.000Z</published>
    <updated>2020-03-30T03:33:52.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序云开发"><a href="#微信小程序云开发" class="headerlink" title="微信小程序云开发"></a>微信小程序云开发</h1><h2 id="什么是微信小程序云开发？"><a href="#什么是微信小程序云开发？" class="headerlink" title="什么是微信小程序云开发？"></a>什么是微信小程序云开发？</h2><p>微信小程序 + 云（云函数（相当于一个后端服务）+ 云数据库）开发…</p><p>好吧，重点就在这个云开发上啦，它弱化了后端和运维概念，无需搭建服务器，使用微信提供的云服务就能完成后端和运维的搭建。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>首先来瞅瞅微信小程序云开发项目的大致目录结构吧</p><p>.</p><p>├── cloudfunctions               // 云函数文件目录<br>    ├── book                                //  这里就放置一些云函数项目<br>├── miniprogram                 // 这个文件夹里存放的就是正常的小程序项目了<br>├── project.config.json        // 项目的配置文件</p><p><code>需要注意的一点是：project.config.json 特殊的配置</code></p><pre><code class="json">{    // 这里定义的对应上面的目录名称    &quot;cloudfunctionRoot&quot;: &quot;cloudfunctions/&quot;,    &quot;miniprogramRoot&quot;: &quot;miniprogram/&quot;,            }</code></pre><p>项目结构并不复杂，就是将传统的小程序项目放入miniprogram 这个单独的文件夹中，再创建另外的一个文件夹来存放云函数。</p><p>那么接下来就来实现一个简单的小程序的云开发吧</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>这里呢我们就完成一个简单的小程序吧，这个小程序呢就只有一个页面（简单吧，哈哈哈哈）</p><p>主要涉及的功能有：</p><ul><li>调用手机摄像头，扫描图书条形码</li><li>然后从豆瓣上通过爬虫获取到图书信息</li><li>将图书信息存入数据库</li><li>页面再从数据库中读取渲染出来</li><li>然后就再做个分页的功能吧，上拉触底后加载下一页</li></ul><p>就这些功能，超简陋的demo，但麻雀虽小五脏俱全。</p><p>下面直奔主题</p><h2 id="小程序页面布局"><a href="#小程序页面布局" class="headerlink" title="小程序页面布局"></a>小程序页面布局</h2><p>页面布局的话，怎么简单怎么来好吧…</p><p><img src="http://blogpic.hjiya.cn/wxxcx1.png" alt></p><p>look先就这样简单的布局下吧</p><p>接下来再来看看js部分</p><h2 id="逻辑编写"><a href="#逻辑编写" class="headerlink" title="逻辑编写"></a>逻辑编写</h2><ol><li><p>那首先我们先来创建数据库，然后渲染出数据吧</p><ol><li>创建数据库的步骤在 微信开发者工具—云开发—数据库中创建即可</li><li>要使用数据库里的数据首先要初始化，如下</li></ol><pre><code class="js">// home.js // 初始化数据库let db = wx.cloud.database()Page({  /**   * 页面的初始数据   */  data: {    books: [],    page: 0,  },  /**   * 生命周期函数--监听页面加载   */  onLoad: function (options) {    this.getBooksList()  // 将读取数据的方法封装成一个函数，方便复用  },  getBooksList(){        // 读取数据库，并将数据存入data    const limit = 3        // 分页操作，表示一页显示几条数据    wx.showLoading()    db.collection(&#39;books&#39;)            // 表示要用哪张表      .orderBy(&#39;create_time&#39;, &#39;desc&#39;)    // 简单的排序      .skip(this.data.page*limit)        // 跳过前n页      .limit(limit)                        // 每次拿取n条      .get({                            // 查询        success: res =&gt; {                          // console.log(res)          if(res.data.length == 0){            this.setData({              isBottom: true            })          }          let newBooks = res.data.map(v =&gt; {    // 简单的将查询结果做个处理            const rate = Math.round(v.rate / 2)            v.rateDisplay = &quot;★★★★★☆☆☆☆☆&quot;.slice(5 - rate, 10- rate)            return v          })          if (this.data.page == 0) {    // 如果是第一页就拉取第一页的数据            this.setData({              books: newBooks            })          } else {            this.setData({            // 因为要有分页效果，所以这里要把新数据拼接上老数据              books: [...this.data.books, ...newBooks]            })          }          wx.hideLoading()        }      })  },</code></pre><p>那么这样就完成了从数据库拿取数据啦</p></li></ol><ol start="2"><li><p>其次我们想点击调出摄像头，解析条形码，然后调用云函数去爬取豆瓣读书的数据</p><pre><code class="html">// home.wxml // 给 button 绑定一个事件吧&lt;button class=&quot;btn&quot; type=&quot;primary&quot; bindtap=&quot;scanQR&quot;&gt;扫书&lt;/button&gt;</code></pre><pre><code class="js">// home.js // 初始化数据let db = wx.cloud.database()Page({  /**   * 页面的初始数据   */  data: {    books: []  },  // 点击扫书触发的事件  scanQR(){    wx.scanCode({      success: res =&gt; {        // console.log(res.result)        wx.showLoading()        wx.cloud.callFunction({        // call调用云函数 ————&gt; 可看下一部分代码          name: &#39;bookfn&#39;,            // 这里要触发哪个云函数          data: {                    // 传参            isbn: res.result,          },          success: ({result}) =&gt; {    // 成功的回调            // console.log(result)            result.create_time = new Date().getTime()  // 添加一个扫书时间            // 将爬取豆瓣的信息存入数据库            db.collection(&#39;books&#39;).add({                  data: result,              success: ret =&gt; {                wx.hideLoading()                if(ret._id){                  wx.showModal({                    title: &#39;提示信息&#39;,                    content: `《${result.title}》添加添加成功`                  })                  this.getBooksList()                }              }            })          }        })      }    })  },</code></pre><p>上面就是点击扫书的逻辑啦，然后重点是调用了下面的云函数</p><pre><code class="js">// cloudfunctions/bookfn/index.js// 云函数入口文件const cloud = require(&#39;wx-server-sdk&#39;)const axios = require(&#39;axios&#39;)const doubanbook = require(&#39;doubanbook&#39;)const cheerio = require(&#39;cheerio&#39;)cloud.init()async function getDoubanBool(isbn) {  // 这是豆瓣url规则  let url = &#39;https://search.douban.com/book/subject_search?search_text=&#39; + isbn  // 请求豆瓣数据  let res = await axios.get(url)  // 创建正则 用来匹配 加密的图书信息  let reg = /window\.__DATA__ = &quot;(.*)&quot;/  // 正则匹配加密的字符串  if(reg.test(res.data)){    // 解密    let searchData = doubanbook(RegExp.$1)[0]    return searchData  }}// getDoubanBool(9787121349126)// 云函数入口函数exports.main = async (event, context) =&gt; {  let { isbn } = event   let bookInfo = await getDoubanBool(isbn)  // 获取book的详情页  let detailPage = await axios.get(bookInfo.url)  // 解析页面来获取指定的内容  let $ = cheerio.load(detailPage.data)  const summary = $(&quot;#link-report .intro&quot;).text()  return {    bid: bookInfo.id,    title: bookInfo.title,    rate: bookInfo.rating.value,    image: bookInfo.cover_url,    summary  }}</code></pre></li><li><p>然后我们最后再处理下触底刷新吧</p><pre><code class="js">  onReachBottom: function () {    this.setData({      page: this.data.page + 1        // 将当前页数加1    })    this.getBooksList()                // 从数据库拉取新数据  },</code></pre></li></ol><p>至此，扫书的小Demo就完成啦，然后我们再按喜好改改页面就ok了，就让我们看看效果图吧</p><p><img src="http://blogpic.hjiya.cn/wxxcx2.png" alt></p>]]></content>
    
    <summary type="html">
    
      微信小程序云开发
    
    </summary>
    
      <category term="技术" scheme="http://blog.hjiya.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>UmiJs</title>
    <link href="http://blog.hjiya.cn/2020/03/28/umi/"/>
    <id>http://blog.hjiya.cn/2020/03/28/umi/</id>
    <published>2020-03-28T12:01:48.000Z</published>
    <updated>2020-03-28T12:16:10.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Umi"><a href="#Umi" class="headerlink" title="Umi"></a>Umi</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>全局安装 Umi</li></ul><p><code>推荐使用 yarn 代替 npm 来安装 umi ， yarn 会针对部分场景做一些缓存以节省时间，你可以输入以下命令来全局安装 yarn，使用yarn后项目中尽量避免再使用npm，不然可能会发生意想不到的错误。</code></p><pre><code class="shell"># 使用 yarn 安装 Umiyarn global add umi# 查看 Umi 版本umi --version</code></pre><h2 id="Umi-快速搭建项目"><a href="#Umi-快速搭建项目" class="headerlink" title="Umi 快速搭建项目"></a>Umi 快速搭建项目</h2><p>创建进入目录后，使用终端工具输入</p><pre><code class="shell"># 脚手架工具，快速搭建项目yarn create umi </code></pre><h3 id="选择项目类型"><a href="#选择项目类型" class="headerlink" title="选择项目类型"></a>选择项目类型</h3><ul><li>这里我选择了 ant-design-pro ~</li></ul><pre><code class="shell">? Select the boilerplate type (Use arrow keys)  ant-design-pro  - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.❯ app             - Create project with a simple boilerplate, support typescript.  block           - Create a umi block.  library         - Create a library with umi.  plugin          - Create a umi plugin.</code></pre><ul><li>然后选择是否使用 TypeScript，推荐使用TypeScript，输入y后回车结束</li></ul><p>看喜好吧，ts不太熟，直接js了</p><pre><code class="shell">? Do you want to use typescript? (y/N)</code></pre><h3 id="项目创建完成"><a href="#项目创建完成" class="headerlink" title="项目创建完成"></a>项目创建完成</h3><pre><code class="shell"># 启动项目yarn start / umi dev</code></pre><h2 id="项目结构分析"><a href="#项目结构分析" class="headerlink" title="项目结构分析"></a>项目结构分析</h2><pre><code>.├── config    ├── config.js            // ** 包含项目的基本配置，如果插件，路由配置    ├── proxy.js            // 前端代理├── mock                    // mock数据├── node_modules├── dist                    // 打包输出├── public├── src                             ├── assets               // 静态资源    ├── *components          // 公共组件  自己创建    ├── layouts              // 全局页面布局    ├── models               // saga models放全局的    ├── pages/               // router页面 umi约定名称        ├── document.ejs     // HTML template        ├── helloworld.jsx   // 页面，导出react组件    ├── *services            // 接口  自己创建    ├── *utils               // 全局方法  自己创建    ├── locales                 // ** 语言配置，Menu配置等                  ├── global.less           ├── tests├── package.json ... ...</code></pre><p>接下来看看Umi的基本使用吧 ——&gt;</p><h2 id="Umi基本使用"><a href="#Umi基本使用" class="headerlink" title="Umi基本使用"></a>Umi基本使用</h2><h3 id="如何创建页面？"><a href="#如何创建页面？" class="headerlink" title="如何创建页面？"></a>如何创建页面？</h3><ul><li>使用终端工具输入命令</li></ul><pre><code class="shell"># 在page目录下 创建 channel 文件夹并在里面创建index.js文件，并初始化css文件为 less 格式 umi g page channel/index --less</code></pre><ul><li>当然也可以直接创建文件或文件夹的形式创建页面</li></ul><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><p>接下来我们配置一下路由</p><pre><code class="js">// config/config.js 中注册 路由routes: [    ... ...+     {+       name: &#39;channel&#39;,+       icon: &#39;table&#39;,+       path: &#39;/channel&#39;,+       component: &#39;./channel&#39;+   },    ... ...]</code></pre><p>以上我们就配置好了路由，在地址栏直接输入 /channel 就可以访问了</p><p>这里我们用到了 Antd 的框架。所以，我们配置好的路由就会出现在侧边栏上啦</p><p><img src="http://blogpic.hjiya.cn/07umi1.png" alt></p><p>但是channel怎么显示为中文呢？那么来看看怎么配置 侧边导航栏</p><pre><code class="js">// .src/locales/zh-CN/menu.js// 我们可以在这个文件中手动的配置我们的侧边导航栏export default {  &#39;menu.welcome&#39;: &#39;欢迎&#39;,  &#39;menu.channel&#39;: &#39;渠道&#39;,  &#39;menu.more-blocks&#39;: &#39;更多区块&#39;,  &#39;menu.home&#39;: &#39;首页&#39;,+ &#39;menu.channel&#39;: &#39;频道&#39;    // 以 menu.name 的形式来配置   ... ...};</code></pre><p>就此，我们就可以就此来写一个简单的Demo了。</p><h2 id="查询表格Demo"><a href="#查询表格Demo" class="headerlink" title="查询表格Demo"></a>查询表格Demo</h2><p>这里我们就简单的编写个查询表格的Demo吧</p><h3 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h3><p>首先我们先将页面布局来整整吧，页面布局很简单，直接上代码</p><pre><code class="jsx">import React, { Component } from &#39;react&#39;;import styles from &#39;./index.less&#39;;import { PageHeaderWrapper } from &#39;@ant-design/pro-layout&#39;;import { Form, Input, Card, Table, Button } from &#39;antd&#39;let columns = [  {    title: &#39;姓名&#39;,    dataIndex: &#39;name&#39;,    key: &#39;name&#39;,  },  {    title: &#39;年龄&#39;,    dataIndex: &#39;age&#39;,    key: &#39;age&#39;,  },  {    title: &#39;城市&#39;,    dataIndex: &#39;city&#39;,    key: &#39;city&#39;,  },]class Channel extends Component {  render() {    return (      &lt;PageHeaderWrapper&gt;          &lt;div&gt;        &lt;Card className={styles.channel}&gt;          &lt;Form&gt;            &lt;Form.Item label=&quot;姓名&quot;&gt;              &lt;Input /&gt;            &lt;/Form.Item&gt;            &lt;Form.Item&gt;              &lt;Button type=&quot;primary&quot; &gt;搜索&lt;/Button&gt;            &lt;/Form.Item&gt;          &lt;/Form&gt;        &lt;/Card&gt;        &lt;Card&gt;          &lt;Table dataSource={[]} columns={columns} /&gt;        &lt;/Card&gt;      &lt;/div&gt;    &lt;/PageHeaderWrapper&gt;    )  }}export default Channel</code></pre><p>来看下效果图</p><p><img src="http://blogpic.hjiya.cn/07umi2.png" alt></p><p>ojbk，接下来先把表格的数据渲染出来吧</p><h3 id="渲染表格数据"><a href="#渲染表格数据" class="headerlink" title="渲染表格数据"></a>渲染表格数据</h3><p>这里呢，大致的逻辑就是：</p><ul><li>首先发送请求拿取数据，</li><li>然后存放到redux中，</li><li>页面到redux中获取数据，</li><li>最后渲染即可。</li></ul><p>那么我们这里Umi里集成好了dva，那我们就直接使用dva来代替原生的redux了</p><pre><code class="js">// src/models/channel.jsimport { getChannelDataAJAX } from &#39;../services/channel&#39;const Model = {      namespace: &#39;channel&#39;,        // 命名空间  state: {                    // 该Model当前的状态，数据都存着    data: []  },  effects: {            // 请求数据，处理异步，里面都是Generator函数    *getChannelData({payload}, {call, put}) {                                // getChannelDataAJAX 就是个封装好的AJAx请求      const res = yield call(getChannelDataAJAX, payload)    // call执行异步函数      yield put({type: &#39;channelData&#39;, payload: res})    // put发出一个Action    },  },  reducers: {            // 更新数据，Action处理器，处理同步动作，更新State状态    channelData(state, {payload}){        // 对应 put({type: &#39;channelData&#39;)      return {...state, data: [...payload.data]}    // 更新 State 的状态    },  }}export default Model</code></pre><p>到此，我们请求好了数据并放在了redux上啦，接下来我们让页面获取到redux里的数据就ok了</p><p>页面想要获取redux里的数据我们可以使用 <code>connect</code> 连接redux</p><p>先看最后一段的 connect 连接</p><pre><code class="jsx">import React, { Component } from &#39;react&#39;;import styles from &#39;./index.less&#39;;import { PageHeaderWrapper } from &#39;@ant-design/pro-layout&#39;;import { Form, Input, Card, Table, Button } from &#39;antd&#39;import { connect } from &#39;dva&#39;;let columns = [    ... ...]class Channel extends Component {  componentDidMount(){    // console.log(this.props)    this.props.getChannelData()        // 3. 页面挂载后，请求数据，保存入redux  }  render() {    let { data } = this.props        // 4. 获取到挂载到this.props上的data，并解构出来    return (      &lt;PageHeaderWrapper&gt;      &lt;div&gt;        &lt;Card className={styles.channel}&gt;          &lt;Form&gt;            &lt;Form.Item label=&quot;姓名&quot;&gt;              &lt;Input /&gt;            &lt;/Form.Item&gt;            &lt;Form.Item&gt;              &lt;Button type=&quot;primary&quot;&gt;搜索&lt;/Button&gt;            &lt;/Form.Item&gt;          &lt;/Form&gt;        &lt;/Card&gt;        &lt;Card&gt;          {/* 5. 然后这里就可以直接渲染出来啦 */}          &lt;Table dataSource={data} columns={columns} /&gt;        &lt;/Card&gt;      &lt;/div&gt;    &lt;/PageHeaderWrapper&gt;    )  }}export default connect(  // 1. mapStateToProps 将 redux里的state映射到this.props上  // {channel} 就表示 state.channel =&gt; ({...channel})   ({channel}) =&gt; ({...channel}),  // 2. mapReducerToProps 将dispatch的方法映射到this.props上  {    getChannelData: () =&gt; ({type: &#39;channel/getChannelData&#39;})   })(Channel)</code></pre><p>Look，数据渲染出来啦。</p><p><img src="http://blogpic.hjiya.cn/07umi3.png" alt></p><p>接下来就继续实现搜索这个小功能吧</p><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>搜索功能大致的逻辑：</p><ul><li>首先在输入框输入要搜索的关键字</li><li>输入完后触发方法，发送请求到后端</li><li>请将响应的结果返回，并更新redux即可</li></ul><p>那首先来看看dva里的Model内容吧，整个搜索的逻辑和首次获取数据类似</p><pre><code class="js">import { getChannelData, getChannelDataBySearchAJAX} from &#39;../services/channel&#39;const Model = {  namespace: &#39;channel&#39;,  state: {    data: []  },  effects: {    *getChannelData({payload}, {call, put}) {      const res = yield call(getChannelData, payload)      yield put({type: &#39;channelData&#39;, payload: res})    },    // 这里是触发搜索的时候发送的异步操作    *getChannelDataBySearch({payload}, {call, put}){      // console.log(payload)                          // getChannelDataBySearchAJAX 发送搜索的AJAX      const res = yield call(getChannelDataBySearchAJAX, payload)      // console.log(res)      // 触发 reducers 中的 channelDataBySearch       yield put({type: &#39;channelDataBySearch&#39;, payload: res})    }  },  reducers: {    channelData(state, {payload}){      return {...state, data: [...payload.data]}    },    // 将获取到的结果做个更新    channelDataBySearch(state, {payload}){      return {...state, data: [...payload.data]}    }  }}export default Model</code></pre><p>然后我们最后来看看页面怎么处理的吧</p><ul><li>因为有个输入框，所以我们要将输入的内容保存下来</li><li>并且输入的内容改变时触发this.setState()来修改State里的数据</li><li>给Button按钮绑定方法可以dispatch</li></ul><pre><code class="jsx">import React, { Component } from &#39;react&#39;;import styles from &#39;./index.less&#39;;import { PageHeaderWrapper } from &#39;@ant-design/pro-layout&#39;;import { Form, Input, Card, Table, Button } from &#39;antd&#39;import { connect } from &#39;dva&#39;;let columns = [... ...]class Channel extends Component {  constructor(props){    super(props)    this.state = {      name: &#39;&#39;        // 1. 输入的内容保存在这里哦    }  }  componentDidMount(){    // console.log(this.props)    this.props.getChannelData()  }  setName = (event) =&gt; {    // 2. 这是修改 state里name的方法    this.setState({      name: event.target.value    })  }  search = () =&gt; {        // 触发搜索的dispatch方法    const { name } = this.state    // console.log(name)    this.props.getChannelDataBySearch(name)  }  render() {    let { data } = this.props    const { name } = this.state    return (      &lt;PageHeaderWrapper&gt;      &lt;div&gt;        &lt;Card className={styles.channel}&gt;          &lt;Form&gt;            &lt;Form.Item label=&quot;姓名&quot;&gt;                {/* 绑定value，以及修改state状态的方法 */}              &lt;Input value={name} onChange={this.setName} /&gt;                &lt;/Form.Item&gt;            &lt;Form.Item&gt;                {/* 绑定 触发搜索的方法 */}              &lt;Button type=&quot;primary&quot; onClick={this.search}&gt;搜索&lt;/Button&gt;            &lt;/Form.Item&gt;          &lt;/Form&gt;        &lt;/Card&gt;        &lt;Card&gt;           &lt;Table dataSource={data} columns={columns} rowKey={({id}) =&gt; id} /&gt;         &lt;/Card&gt;      &lt;/div&gt;    &lt;/PageHeaderWrapper&gt;    )  }}export default connect(  ({channel}) =&gt; ({...channel}),  {    getChannelData: () =&gt; ({type: &#39;channel/getChannelData&#39;}),    // 3. dispatch的方法    getChannelDataBySearch: (name) =&gt; ({type: &#39;channel/getChannelDataBySearch&#39;, payload: {name}})  })(Channel)</code></pre><p>唔，就此，搜索功能完成啦</p><p>好了，这就是个小小的Demo，用来初探Umi~ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Umi&quot;&gt;&lt;a href=&quot;#Umi&quot; class=&quot;headerlink&quot; title=&quot;Umi&quot;&gt;&lt;/a&gt;Umi&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;u
      
    
    </summary>
    
      <category term="技术" scheme="http://blog.hjiya.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>react</title>
    <link href="http://blog.hjiya.cn/2020/03/26/react/"/>
    <id>http://blog.hjiya.cn/2020/03/26/react/</id>
    <published>2020-03-26T02:58:19.000Z</published>
    <updated>2020-03-26T03:44:11.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-入门笔记"><a href="#React-入门笔记" class="headerlink" title="React 入门笔记"></a>React 入门笔记</h1><h2 id="React-应用创建方法"><a href="#React-应用创建方法" class="headerlink" title="React 应用创建方法"></a>React 应用创建方法</h2><p>使用 create react app 脚手架命令快速创建 React应用</p><pre><code class="shell">npx create-react-app name</code></pre><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>在 index.js 中渲染上页面的核心代码</p><pre><code class="js">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;// 创建了一个简单的React元素const app = &lt;h1&gt;Welcome React&lt;/h1&gt;ReactDOM.render(  app,  document.querySelector(&#39;#root&#39;))</code></pre><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><h3 id="使用函数创建组件"><a href="#使用函数创建组件" class="headerlink" title="使用函数创建组件"></a>使用函数创建组件</h3><pre><code class="js">const App = (props) =&gt; {  return (    &lt;div&gt;      &lt;h1&gt;welcome {props.title}&lt;/h1&gt;    &lt;/div&gt;  )}ReactDOM.render(  &lt;App title=&quot;1901&quot;/&gt;,  document.querySelector(&#39;#root&#39;))</code></pre><h3 id="Class类创建组件"><a href="#Class类创建组件" class="headerlink" title="Class类创建组件"></a>Class类创建组件</h3><pre><code class="js">import React from &#39;react&#39;import {render} from &#39;react-dom&#39;// 定义组件的第二种方式 --&gt; 类class App extends React.Component {  render(){    return (      &lt;div&gt;        &lt;h1&gt;Welcome React {this.props.title}&lt;/h1&gt;             &lt;/div&gt;    )  }};render(  &lt;App title=&#39;2019&#39;/&gt;,  document.querySelector(&#39;#root&#39;));// 底层原理// &lt;App title=&quot;2019&quot; /&gt;  编译成以下代码// const app = new App({//   title: &quot;2019&quot;// }).render()</code></pre><h2 id="jsx-原理"><a href="#jsx-原理" class="headerlink" title="jsx 原理"></a>jsx 原理</h2><p>虚拟DOM树方式</p><p>React.createElemet(type,[props],[…children]) 是一个方法，用于创建元素，参数：（标签名，标签属性，子元素…）</p><pre><code class="js">// class App extends Component {//   render(){//     return (//       &lt;div&gt;//         &lt;h1&gt;Welcome React&lt;/h1&gt;       //       &lt;/div&gt;//     )//   }// }// 底层编译为 以下方式class App extends Component {  render(){    return (      React.createElement(        &#39;div&#39;,        {          className: &#39;dv1&#39;,          id: &#39;appRoot&#39;        },        React.createElement(          &#39;h1&#39;,          {            className: &#39;title&#39;,          },          &#39;Welcome React&#39;        )      )    )  }}</code></pre><h2 id="样式类名的绑定"><a href="#样式类名的绑定" class="headerlink" title="样式类名的绑定"></a>样式类名的绑定</h2><ul><li>内联样式创建</li><li>使用 styled-components 插件 定义样式组件，再使用样式组件包裹</li><li>使用 className 的方法直接添加 类名</li><li>使用 classnames 插件，动态添加 类名</li></ul><pre><code class="js">// 定义样式组件const Title = styled.h1`  color: red`const Header = () =&gt; &lt;h1&gt;hi&lt;/h1&gt;// 定义组件的第二种方式 --&gt; 类class App extends Component {  render(){    // 使用内联样式创建    const style = {color: &quot;red&quot;}    return (      &lt;div&gt;        &lt;Header /&gt;        &lt;h1 style={style}&gt;Welcome React {this.props.title}&lt;/h1&gt;           {/* 使用 className 方式  注意这里样式类名需要 className 而不是 class */}        &lt;h1 className=&quot;has-test-pink&quot;&gt;Welcome React {this.props.title} 2&lt;/h1&gt;         {/* 使用 classnames 插件 绑定动态样式 */}        &lt;h1 className={classNames(&#39;a&#39;,{&#39;has-test-pink&#39;: true})}&gt;Welcome React {this.props.title} 3&lt;/h1&gt;        {/* 使用定义好的样式组件  */}        &lt;Title className={classNames(&#39;a&#39;,{&#39;has-test-pink&#39;: true})}&gt;Welcome React {this.props.title} 4&lt;/Title&gt;       &lt;/div&gt;    )  }}</code></pre><h2 id="向子组件传值做类型检查"><a href="#向子组件传值做类型检查" class="headerlink" title="向子组件传值做类型检查"></a>向子组件传值做类型检查</h2><p>prop-types </p><ul><li><p>函数组件的类型检查方法</p><pre><code class="html">&lt;TodoHeader title=&quot;代办事项&quot; x={1} y={2}&gt;hi&lt;/TodoHeader&gt;</code></pre><pre><code class="js">TodoHeader.propTypes = {title: PropTypes.string,x: PropTypes.number.isRequired,   // 这里可以链式操作y: PropTypes.number,}</code></pre></li><li><p>类组件的类型检查方法</p><pre><code class="html">&lt;TodoInput btnText=&quot;添加吧&quot;/&gt;</code></pre><pre><code class="js">export default class TodoInput extends Component {// 静态属性static propTypes = {  btnText: PropTypes.string}render() {  return (    &lt;div&gt;      &lt;input /&gt;&lt;button&gt;{this.props.btnText}&lt;/button&gt;    &lt;/div&gt;  )}}</code></pre></li></ul><h2 id="子组件传参设置默认值"><a href="#子组件传参设置默认值" class="headerlink" title="子组件传参设置默认值"></a>子组件传参设置默认值</h2><ul><li>函数组件设置默认值<pre><code class="js">TodoHeader.defaultProps = {title: &#39;Welcome&#39;}</code></pre></li><li>类组件设置默认值<pre><code class="js">export default class TodoInput extends Component {static propTypes = {  btnText: PropTypes.string}static defaultProps = {  btnText: &#39;添加&#39;}render() {  return (    &lt;div&gt;      &lt;input /&gt;&lt;button&gt;{this.props.btnText}&lt;/button&gt;    &lt;/div&gt;  )}}</code></pre></li></ul><h2 id="组件自己的数据状态"><a href="#组件自己的数据状态" class="headerlink" title="组件自己的数据状态"></a>组件自己的数据状态</h2><p>class 类组件 -有状态组件<br>function 函数组件 -无状态组件（Hook有解决办法）</p><p>使用 this.state.name 来获取数据</p><p><code>state</code> 只有 class类组件才会有</p><pre><code class="js">export default class App extends Component {  // 方法一  // state = {  //   title: &#39;代办事项App&#39;  // }  // 方法二  constructor(){    super()    this.state = {      title: &#39;待办事项App&#39;    }  }  render() {    return (      &lt;Fragment&gt;        &lt;TodoHeader title={this.state.title} x={1} y={2}&gt;          hi        &lt;/TodoHeader&gt;        &lt;TodoInput btnText=&quot;添加吧&quot;/&gt;        &lt;TodoList /&gt;        {this.state.title}      &lt;/Fragment&gt;    )  }}</code></pre><h2 id="渲染数据"><a href="#渲染数据" class="headerlink" title="渲染数据"></a>渲染数据</h2><ul><li>直接渲染<pre><code class="js">{this.state.name}</code></pre></li><li><p>html文本渲染(Vue中的v-html)</p><pre><code class="js">&lt;div dangerouslySetInnerHTML={{__html: this.state.htxt}} /&gt;</code></pre></li><li><p>列表渲染</p><pre><code class="js">this.props.todos.map(item=&gt;{return (  &lt;TodoItem key={item.id} {...item} /&gt;)})</code></pre></li></ul><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>使用 <code>this.setState()</code> 的方法来修改数据</p><p>this.setState() 需要两个参数 </p><h3 id="第一个参数又有两种情况"><a href="#第一个参数又有两种情况" class="headerlink" title="第一个参数又有两种情况"></a>第一个参数又有两种情况</h3><p>第一种情况是一个对象：</p><pre><code class="js">handleLikeClick = () =&gt; {  // 需要使用 setState 修改数据  this.setState({    isLike: !this.state.isLike  })}</code></pre><p>第二种情况是一个方法： 方法中有个参数，保存着修改数据前的数据</p><pre><code class="js">this.setState((prev)=&gt;{  console.log(prev)  return {    isLike: !this.state.isLike  }})</code></pre><h3 id="第二个参数为一个回调函数，来获取最新的数据状态"><a href="#第二个参数为一个回调函数，来获取最新的数据状态" class="headerlink" title="第二个参数为一个回调函数，来获取最新的数据状态"></a>第二个参数为一个回调函数，来获取最新的数据状态</h3><pre><code class="js">this.setState((prev)=&gt;{  console.log(prev)  return {    isLike: !this.state.isLike  }},()=&gt;{  console.log(this.state.isLike)})</code></pre><h3 id="setState-特性"><a href="#setState-特性" class="headerlink" title="setState 特性"></a>setState 特性</h3><ul><li><p>setState是异步操作</p></li><li><p>⽤setState更新状态⽽不能直接修改</p><pre><code class="js">this.state.counter += 1; //错误的</code></pre></li><li><p>且setState是批量执行的，因此对同一个状态执行多次只起一次作用，多个状态更新可以放在同一个setState中进行</p><pre><code class="js">componentDidMount(){this.setState({counter: this.state.counter + 1});   this.setState({counter: this.state.counter + 1});   this.setState({counter: this.state.counter + 1});}// 最后 Counter的值为 1</code></pre></li></ul><p>（setState只有在合成事件和钩⼦子函数中是异步的，在原生事件和setTimeout、setInterval中都是同步的）</p><p>使其同步的方法</p><p>第一种方法 如上this.setState() 传入回调函数</p><p>第二种方法就是原生事件 </p><pre><code class="js">componentDidMount(){  document.getElementsByTagName(&#39;button&#39;)[0].addEventListener(&#39;click&#39;, () =&gt; {    this.setState({      counter: this.state.counter + 2    })  })}</code></pre><p>第三种就是定时器</p><pre><code class="js">handleLikeClick = () =&gt; {  setTimeout(() =&gt; {    this.setState({      counter: this.state.counter + 1    })  }, 0);}</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>onClick，onChange….</p><ul><li><p>方法一</p><pre><code class="html">&lt;input onChange={this.handleInputChange} type=&quot;text&quot; value={this.state.inputValue}/&gt;</code></pre><pre><code class="js">handleInputChange = (e)=&gt; {this.setState({  inputValue: e.currentTarget.value})}</code></pre></li><li><p>方法二：可以传递参数</p><pre><code class="html">&lt;button onClick={this.handleClick.bind(this,123)}&gt;{this.props.btnText}&lt;/button&gt;</code></pre><pre><code class="js">handleClick(num){console.log(this.state.inputValue,num)}</code></pre></li></ul><h2 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h2><ul><li><p>外面再包层匿名函数，因为使用这种事件是匿名函数，渲染的时候就会自动执行，所以外面再加层匿名函数</p><pre><code class="html">&lt;button onClick={() =&gt; {this.handleBtnClick(123)}}&gt;事件传参&lt;/button&gt;</code></pre></li><li><p>使用.bind(this,参数列表)</p></li></ul><h2 id="hook-钩子函数"><a href="#hook-钩子函数" class="headerlink" title="hook 钩子函数"></a>hook 钩子函数</h2><p>hook 钩子函数可以使 函数组件也能拥有 类组件中自己的状态和其他特性</p><pre><code class="js">// 需要导入 useState useEffect hook来完成操作import React, { useState, useEffect } from &#39;react&#39;export default function User() {  // const date = new Date()  const [date, setDate] = useState(new Date())  // 一个变量定义一次  useEffect(() =&gt; {    const timeid = setInterval(() =&gt; {      setDate(new Date())    }, 1000)    return () =&gt; clearInterval(timeid)  })  return (    &lt;div&gt;      &lt;h1&gt;{date.toLocaleTimeString()}&lt;/h1&gt;    &lt;/div&gt;  )}</code></pre><h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><pre><code class="js">// 父组件&lt;Search store={store} title=&quot;props&quot; tellme={tellme} /&gt;// 子组件// this.props.title  this.props.tellme 的形式来接收</code></pre><h3 id="createContext-是-react-提供的跨组件的方法"><a href="#createContext-是-react-提供的跨组件的方法" class="headerlink" title="createContext 是 react 提供的跨组件的方法"></a>createContext 是 react 提供的跨组件的方法</h3><p>createContext 这个方法的结果是一个对象，里面有2个组件，Provider和Consumer</p><p>Provider 用于提供状态</p><p>Consumer 用于接收状态</p><pre><code class="js">// 想解构出来const {  Provider,  Consumer:CounterConsumer    } = createContext()class CounterProvider extends Component {  constructor(){    super()    // 这里的状态是共享的，任何CounterProvider的子孙组件，都可以使用CounterConsumer来接收    this.state = {      count: 100    }  }  // 这里的方法也会继续通过Provider共享下去  incrementCount = () =&gt; {    this.setState({      count: this.state.count + 1    })  }  decrementCount = () =&gt; {    this.setState({      count: this.state.count - 1    })  }  render(){    return (      // 使用 Provider 这个组件 ，必须有个value值，这个Value中科院传递任何的数据，一般传递一个对象      &lt;Provider value={{count: this.state.count,      onIncrementCount: this.incrementCount,      onDecrementCount:this.decrementCount}}&gt;        {this.props.children}      &lt;/Provider&gt;    )  }}// 定义的子孙组件，使用 CounterConsumer 来接收count class Counter extends Component {  render(){    return (      &lt;CounterConsumer&gt;        {          //注意，这里的CounterConsumer包裹着的必须是一个方法，          //参数是Provider提供的Value          ({count}) =&gt; {            return &lt;span&gt;{count}&lt;/span&gt;          }        }      &lt;/CounterConsumer&gt;    )  }}</code></pre><h2 id="HOC-高阶组件-Height-order-component"><a href="#HOC-高阶组件-Height-order-component" class="headerlink" title="HOC 高阶组件 Height-order component"></a>HOC 高阶组件 Height-order component</h2><p>可以劫持页面渲染</p><pre><code class="js">// App.jsimport React, { Component } from &#39;react&#39;// 导入 高阶组件import witCopyright from &#39;./witCopyright&#39;class App extends Component {  render(){    return (      &lt;div&gt;        &lt;h1&gt;h&lt;/h1&gt;         &lt;/div&gt;    )  }}// 使用高阶组件，并将 App 组件 作为参数传入export default witCopyright(App)</code></pre><pre><code class="js">// 高阶组件 witCopyright.jsimport React, { Component } from &#39;react&#39;const witCopyright = (YourComponent) =&gt; {  return class witCopyright extends Component {    render() {      return (        &lt;&gt;          这里就是 刚才传入函数，将其使用          这里注意 要使用 {...this.props} 更改 props          &lt;YourComponent {...this.props}/&gt;          &lt;div&gt;&amp;copy; 2019 &amp;emsp; 黄即呀&lt;/div&gt;        &lt;/&gt;      )    }  }}export default witCopyright</code></pre><h2 id="使用装饰器-装饰高阶组件的写法"><a href="#使用装饰器-装饰高阶组件的写法" class="headerlink" title="使用装饰器 装饰高阶组件的写法"></a>使用装饰器 装饰高阶组件的写法</h2><p>安装包</p><p>第一步</p><blockquote><p>npm i react-app-rewired –sava-dev</p></blockquote><p>然后修改 page.json 文件，修改为 react-app-rewired</p><pre><code class="js">&quot;scripts&quot;: {  &quot;start&quot;: &quot;react-app-rewired start&quot;,  &quot;build&quot;: &quot;react-app-rewired build&quot;,  &quot;test&quot;: &quot;react-app-rewired test&quot;,  &quot;eject&quot;: &quot;react-scripts eject&quot;}</code></pre><p>然后再 项目目录下创建一个 config-overrides.js 即可</p><pre><code class="js">// config-overrides.jsmodule.exports = (config) =&gt; {  // 在这里可以对 config 进行配置  return config}</code></pre><p>第二步 安装 customize-cra 来方便定义配置项</p><blockquote><p>npm i customize-cra –sava-dev</p></blockquote><p>修改 config-overrides.js</p><pre><code class="js">const {override,addDecoratorsLegacy} = require(&#39;customize-cra&#39;)module.exports = override(  addDecoratorsLegacy())</code></pre><blockquote><p>npm i @babel/plugin-proposal-decorators -D</p></blockquote><h2 id="状态管理-redux-手动连接"><a href="#状态管理-redux-手动连接" class="headerlink" title="状态管理 redux 手动连接"></a>状态管理 redux 手动连接</h2><h3 id="手动实现-redux-状态管理"><a href="#手动实现-redux-状态管理" class="headerlink" title="手动实现 redux 状态管理"></a>手动实现 redux 状态管理</h3><p>简单的redux的实现 ， 详情见 redux-pronciple-2.html</p><pre><code class="js">    const countState = {      count: 5    }    const changeState = (state,action) =&gt; {      if(!state){        return countState      }      switch(action.type){        default:           return state;        case &quot;JIAN&quot;:           return {            ...state,            count: state.count - action.n          }          break;        case &quot;JIA&quot;:        return {            ...state,            count: state.count + action.n          }      }    }    const createStore = (reducer) =&gt; {      let state = null      const getState = () =&gt; state      const Listeners = []      const subScribe = (Listener) =&gt; Listeners.push(Listener)      const dispatch = (action) =&gt; {        state = changeState(state,action)        Listeners.forEach(listener =&gt; listener())      }      dispatch({})      return {        getState,        dispatch,        subScribe      }    }    const store = createStore(changeState)    const renderCount = () =&gt; {      countDisplay.innerHTML = store.getState().count    }    renderCount()    store.subScribe(renderCount)</code></pre><h3 id="使用-redux"><a href="#使用-redux" class="headerlink" title="使用 redux"></a>使用 redux</h3><ul><li>首先在 src目录下新建 2个 文件夹<ul><li>reducers</li><li>actions</li></ul></li><li>然后在 src 目录下新建一个文件：store.js<br><code>`</code>js<br>import { createStore } from ‘redux’<br>// 导入 reducers<br>import rootReducer from ‘./reducers’</li></ul><p>export default createStore(rootReducer)</p><pre><code>- 在reducers文件夹下新建一个 car.js 并导出```jsconst initState = []export default (state = initState,action) =&gt; {  switch(action.type){    default:       return state  }}</code></pre><ul><li>在reducers文件夹下新建一个 index.js 文件用来合并导出reducers中的其他文件<br><code>`</code>js<br>// 用于合并多个 reducers<br>import { combineReducers} from ‘redux’<br>import car from ‘./car’</li></ul><p>export default combineReducers({<br>  car<br>})</p><pre><code>`......太痛苦了......`## 状态管理 React-redux 自动连接- 创建 reducers- 合并 reducers- createStore- Provider store = { store }- connect(mapStateToProps,{...actionCreators})(YourComponent)- actionCreators- 修改reducers### 首先创建 reducers 文件目录下的 reducer分类文件```js// 未来避免 actionType 重复，一般会把action放在文件里，统一管理import actionType from &#39;../actions/actionType&#39;// 对于 购物车 来说，这里有个初始化的状态const initState = [  {    id: 1,    title: &#39;Apple&#39;,    price: 999,    amount: 10  },  {    id: 2,    title: &#39;Orange&#39;,    price: 99,    amount: 6  }]// 创建 购物车的 reducer ，是个纯函数，reducer的固定写法 两个参数// 第一个参数是 state并有一个初始值// 第二个参数是 actionexport default (state = initState,action) =&gt; {  // 根据不同的 action 来处理不同的结果，每次返回新的state，返回的类型要一样  switch(action.type){    // 一定要有default ，当actionType 不对时候，就不做任何处理，返回上一次的state    default:       return state;    case actionType.CAR_AMOUNT_INCREMENT:      return state.map(item =&gt; {        if(item.id === action.payload.id){          item.amount += 1        }        return item      })      case actionType.CAR_AMOUNT_DECREMENT:      return state.map(item =&gt; {        if(item.id === action.payload.id){          item.amount -= 1        }        return item      })  }}</code></pre><h3 id="reducers目录下创建-index-js-合并多个-reducer-并导出"><a href="#reducers目录下创建-index-js-合并多个-reducer-并导出" class="headerlink" title="reducers目录下创建 index.js 合并多个 reducer 并导出"></a>reducers目录下创建 index.js 合并多个 reducer 并导出</h3><p>由于在实际中，只有单一的store,但是状态会有很多分类，因此需要划分reducer，但createStore() 参数只接受一个reducer，所以redux提供了一个合并多个reducer的方法：combineReducers</p><pre><code class="js">// 用于合并多个 reducersimport { combineReducers} from &#39;redux&#39;// 引入 car reducer，如果有多个，继续引入import car from &#39;./car&#39;// 导出合并后的 reducerexport default combineReducers({  // 把多个 reducer作为 combineReducers 参数对象 传入，在外部就可以通过 store.getState().car 来获取到 carReducer里面的state  car})</code></pre><h3 id="创建-Action-目录，然后创建特定的-car-js"><a href="#创建-Action-目录，然后创建特定的-car-js" class="headerlink" title="创建 Action 目录，然后创建特定的 car.js"></a>创建 Action 目录，然后创建特定的 car.js</h3><pre><code class="js">import actionType from &#39;./actionType&#39;// action 有两种写法// 一：写成一个对象，缺点不好传递参数// export const increment = {//   type: actionType.CAR_AMOUNT_INCREMENT// }// 二：写成一个方法，返回一个对象，这个对象才是真正的actionexport const increment = (id) =&gt; {  return {    type: actionType.CAR_AMOUNT_INCREMENT,    payload:{      id    }  }}export const decrement = (id) =&gt; {  return {    type: actionType.CAR_AMOUNT_DECREMENT,    payload:{      id    }  }}</code></pre><h3 id="在Action目录下创建-actionType-来统一管理-action"><a href="#在Action目录下创建-actionType-来统一管理-action" class="headerlink" title="在Action目录下创建 actionType 来统一管理 action"></a>在Action目录下创建 actionType 来统一管理 action</h3><pre><code class="js">export default {  CAR_AMOUNT_INCREMENT: &#39;CAR_AMOUNT_INCREMENT&#39;,  CAR_AMOUNT_DECREMENT: &#39;CAR_AMOUNT_DECREMENT&#39;,}</code></pre><h3 id="创建-store-js"><a href="#创建-store-js" class="headerlink" title="创建 store.js"></a>创建 store.js</h3><pre><code class="js">// createStore 是 redux用来创建store的方法import { createStore } from &#39;redux&#39;// 引入合并后的 reducerimport rootReducer from &#39;./reducers&#39;// createStore(rootReducer) 第一个参数必须是 一个reducerexport default createStore(rootReducer)</code></pre><h3 id="最后使用放在应用程序最顶层，且必须有-store-属性"><a href="#最后使用放在应用程序最顶层，且必须有-store-属性" class="headerlink" title="最后使用放在应用程序最顶层，且必须有 store 属性"></a>最后使用<producer></producer>放在应用程序最顶层，且必须有 store 属性</h3><pre><code class="js">import React from &#39;react&#39;import {render} from &#39;react-dom&#39;import App from &#39;./App&#39;import store from &#39;./store&#39;// Rrovier 是 react-redux 提供的一个组件import { Provider } from &#39;react-redux&#39;render(  // 这个store 的值，就是我们所创建的 store  // 只要被 Producer 包裹的组件，所有的后代组件都可以使用Redux.connect做连接  &lt;Provider store={store}&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.querySelector(&quot;#root&quot;))</code></pre><h3 id="子组件连接获取数据"><a href="#子组件连接获取数据" class="headerlink" title="子组件连接获取数据"></a>子组件连接获取数据</h3><pre><code class="js">import React, { Component } from &#39;react&#39;// 导入 actionCreatorsimport { increment,decrement } from &#39;../../actions/car&#39;// connect 执行后是一个高阶组件import { connect } from &#39;react-redux&#39;class CarList extends Component {  render() {    return (      &lt;table&gt;        &lt;tbody&gt;          {            this.props.carList.map(item =&gt; {              return (                &lt;tr key={item.id}&gt;                  &lt;td&gt;{item.id}&lt;/td&gt;                    &lt;td&gt;{item.title}&lt;/td&gt;                  &lt;td&gt;{item.price}&lt;/td&gt;                  &lt;td&gt;                    &lt;button onClick={()=&gt;{                      this.props.dispatch(decrement(item.id))                    }}&gt;-&lt;/button&gt;                    &lt;span&gt;{item.amount}&lt;/span&gt;                    &lt;button onClick={()=&gt;{                      this.props.dispatch(increment(item.id))                    }}&gt;+&lt;/button&gt;                  &lt;/td&gt;                  &lt;td&gt;&lt;/td&gt;                &lt;/tr&gt;              )            })          }        &lt;/tbody&gt;      &lt;/table&gt;    )  }}// 这里的 state 实际上就是 store.getState()的值const mapStateToProps = (state) =&gt; {  // 这里return了什么，组件中就可以this.props来获取  return {    carList: state.car  }}// connect方法常用的参数// 第一个参数： mapStateToProps 作用就是从store里把state注入到当前组件props// 第二个参数：可以是mapDisPatchProps，这个主要作用就是将action生成的方法注入到单签组件的props// 直接第二个参数传递一个对象，里面的对象就是actionCrators，只要传入了，在组件中就可以通过this.props.actionCreator来调用export default connect(mapStateToProps)(CarList)</code></pre><h2 id="redux-处理-异步操作-需要一个中间件处理"><a href="#redux-处理-异步操作-需要一个中间件处理" class="headerlink" title="redux 处理 异步操作 需要一个中间件处理"></a>redux 处理 异步操作 需要一个中间件处理</h2><blockquote><p>npm install redux-thunk</p></blockquote><ul><li><p>先在 store 中传入applyMiddleware(thunk)</p><pre><code class="js">export default createStore(rootReducer,applyMiddleware(thunk))</code></pre></li><li><p>然后在 actions 中导出以下代码</p><pre><code class="js">export const decrementAsync = id =&gt; dispatch =&gt; {setTimeout(() =&gt; {  dispatch(decrement(id))}, 1000);}</code></pre></li></ul><h2 id="路由-React-Router"><a href="#路由-React-Router" class="headerlink" title="路由 React Router"></a>路由 React Router</h2><h3 id="简单匹配"><a href="#简单匹配" class="headerlink" title="简单匹配"></a>简单匹配</h3><p>Web 上安装只需要安装这一个就可以了</p><blockquote><p>npm i react-router-dom -s</p></blockquote><p>只需要在最顶层使用一次Router就可以了<br>Router 只需要在最顶级使用一次就可以了</p><pre><code class="js">import React from &#39;react&#39;import {render} from &#39;react-dom&#39;import App from &#39;./App&#39;// 将 BrowserRouter 重命名为 Router ，方便调用// HashRouter and BrowserRouter 可以选择 路由模式// Route 组件相当于 Vue中 的 &lt;router-view&gt;&lt;/router-view&gt;import { BrowserRouter as  Router,Route } from &#39;react-router-dom&#39;render(  // 最顶层只需使用 Router 包裹一次就可以了  &lt;Router&gt;    使用 Route组件 来渲染组件    &lt;Route component={App}/&gt;  &lt;/Router&gt;,  document.querySelector(&quot;#root&quot;))</code></pre><h3 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h3><pre><code class="js">import React, { Component } from &#39;react&#39;// 路由跳转需要使用到 Link 组件，相当于Vue中的,&lt;router-link&gt;&lt;/router-link&gt;// NavLink 作用和 Link 作用差不多，但 NavLink可以给链接自动添加一些属性// Redirect 组件 负责 页面重定向 import { Route, Link, NavLink, Redirect } from &#39;react-router-dom&#39;import {  Home,  Artical,  Users} from &#39;./views&#39;export default class App extends Component {  render() {    return (      &lt;div&gt;        &lt;ul&gt;          &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;          &lt;li&gt;&lt;Link to=&quot;/artical&quot;&gt;文章&lt;/Link&gt;&lt;/li&gt;          &lt;li&gt;&lt;NavLink to=&quot;/users&quot;&gt;用户&lt;/NavLink&gt;&lt;/li&gt;        &lt;/ul&gt;        页面重定向        &lt;Redirect to=&quot;/home&quot; from=&quot;/&quot;&gt;&lt;/Redirect&gt;        &lt;Route component={Home} path=&quot;/home&quot; /&gt;        &lt;Route component={Artical} path=&quot;/artical&quot; /&gt;        &lt;Route component={Users} path=&quot;/users&quot; /&gt;      &lt;/div&gt;    )  }}</code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li>点击链接后，链接不消失，在链接的页面上放置 <router></router></li></ul><p>artical.js</p><pre><code class="js">import React, { Component } from &#39;react&#39;import {  Link,  Route} from &#39;react-router-dom&#39;import ArticalDetail from &#39;./ArticalDetail&#39;export default class Artical extends Component {  render() {    return (      &lt;div&gt;        &lt;Link to=&quot;/artical/1&quot;&gt;文章一&lt;/Link&gt;        &lt;Link to=&quot;/artical/2&quot;&gt;文章二&lt;/Link&gt;        这里设置 path=&quot;/artical/:id&quot;        &lt;Route component={ArticalDetail} path=&quot;/artical/:id&quot; /&gt;      &lt;/div&gt;    )  }}</code></pre><p>组件中 获取参数的方法</p><pre><code class="js">{this.props.match.params.id}</code></pre><ul><li>点击链接后链接消失,即将 <router> 放置值与连接页面同级的页面</router></li></ul><p>App.js</p><pre><code class="js">import React, { Component } from &#39;react&#39;import { Route, Link, NavLink, Redirect } from &#39;react-router-dom&#39;import {  Home,  Artical,  Users,  ArticalDetail} from &#39;./views&#39;export default class App extends Component {  render() {    return (      &lt;div&gt;        &lt;ul&gt;          &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;          &lt;li&gt;&lt;Link to=&quot;/artical&quot;&gt;文章&lt;/Link&gt;&lt;/li&gt;          &lt;li&gt;&lt;NavLink to=&quot;/users&quot;&gt;用户&lt;/NavLink&gt;&lt;/li&gt;        &lt;/ul&gt;        &lt;Redirect to=&quot;/home&quot;&gt;&lt;/Redirect&gt;        &lt;Route component={Home} path=&quot;/home&quot; /&gt;        注意要加上 exact（完全匹配）        &lt;Route component={Artical} path=&quot;/artical&quot; exact/&gt;        &lt;Route component={ArticalDetail} path=&quot;/artical/:id&quot; /&gt;        &lt;Route component={Users} path=&quot;/users&quot; /&gt;      &lt;/div&gt;    )  }}</code></pre><h3 id="处理-404"><a href="#处理-404" class="headerlink" title="处理 404"></a>处理 404</h3><pre><code class="js">import React, { Component } from &#39;react&#39;import { Route, Link, NavLink, Redirect, Switch } from &#39;react-router-dom&#39;import {  Home,  Artical,  Users,  ArticalDetail,  NotFound} from &#39;./views&#39;export default class App extends Component {  render() {    return (      &lt;div&gt;        &lt;ul&gt;          &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;          &lt;li&gt;&lt;Link to=&quot;/artical&quot;&gt;文章&lt;/Link&gt;&lt;/li&gt;          &lt;li&gt;&lt;NavLink to=&quot;/users&quot;&gt;用户&lt;/NavLink&gt;&lt;/li&gt;        &lt;/ul&gt;        注意 需要使用 Switch 包裹，不然符合条件的都回去渲染        &lt;Switch&gt;          &lt;Route component={Home} path=&quot;/home&quot; /&gt;          &lt;Route component={Artical} path=&quot;/artical&quot; exact/&gt;          &lt;Route component={ArticalDetail} path=&quot;/artical/:id&quot; /&gt;          &lt;Route component={Users} path=&quot;/users&quot; /&gt;          &lt;Route component={NotFound} path=&quot;/404&quot; /&gt;          &lt;Redirect to=&quot;/home&quot; from=&quot;/&quot; exact /&gt;          &lt;Redirect to=&quot;/404&quot; /&gt;        &lt;/Switch&gt;      &lt;/div&gt;    )  }}</code></pre><h2 id="路由其他API"><a href="#路由其他API" class="headerlink" title="路由其他API"></a>路由其他API</h2><h3 id="使用-render-function-俩代替-component"><a href="#使用-render-function-俩代替-component" class="headerlink" title="使用 render(function) 俩代替 component={}"></a>使用 render(function) 俩代替 component={}</h3><p>优点，可以传递参数</p><pre><code class="js">  &lt;Router&gt;    使用render使，里面要是个函数，其中有一个参数为 路由信息 使用{...props}向下合并传递    &lt;Route render={(props)=&gt;&lt;App {...props} x={1}/&gt;} path=&quot;/&quot; /&gt;  &lt;/Router&gt;,</code></pre><h3 id="隐式传参代替url传参"><a href="#隐式传参代替url传参" class="headerlink" title="隐式传参代替url传参"></a>隐式传参代替url传参</h3><p>可以用来埋点分享</p><pre><code class="js">&lt;Link to={{  pathname: 'artical/2',  state: {    form: 'artical'  }}}&gt;文章二&lt;/Link&gt;</code></pre><ul><li>埋点<br>发送数据方法</li><li>ajax</li><li>img: 兼容性最好<pre><code class="js">  const img = new Image()  img.src = &quot;http://...../button-01.gif?x=16....&quot;</code></pre></li><li>sendBeacon 兼容性不好，成功率最高</li></ul><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><ul><li><p>history.push(‘…’)</p><pre><code class="js">export default class ArticalDetail extends Component {goHome = () =&gt; {  this.props.history.push(&#39;/&#39;)}render() {  console.log(this.props)  return (    &lt;div&gt;      文章详情      {this.props.match.params.id}      &lt;button onClick={this.goHome}&gt;返回首页&lt;/button&gt;    &lt;/div&gt;  )}}</code></pre></li><li><p>this.props.history.push({对象})</p><pre><code class="js">goHome = () =&gt; {this.props.history.push({  pathname: &#39;/&#39;,  state: {    x: 1  }})}render() {console.log(this.props)return (  &lt;div&gt;    文章详情    {this.props.match.params.id}    &lt;button onClick={this.goHome}&gt;返回首页&lt;/button&gt;  &lt;/div&gt;)}</code></pre></li></ul><h3 id="withRouter-高阶组件"><a href="#withRouter-高阶组件" class="headerlink" title="withRouter 高阶组件"></a>withRouter 高阶组件</h3><p>若想要点击一个组件，触发组件内的事件并使用当前的参数，则可以使用 withRouter 高阶组件包裹 组件</p><pre><code class="js">export default withRouter(BackHome)</code></pre><h2 id="Antd-蚂蚁设计-UI库"><a href="#Antd-蚂蚁设计-UI库" class="headerlink" title="Antd 蚂蚁设计 UI库"></a>Antd 蚂蚁设计 UI库</h2><blockquote><p>npm i antd -s</p></blockquote><h3 id="配置-Antd"><a href="#配置-Antd" class="headerlink" title="配置 Antd"></a>配置 Antd</h3><p><a href="https://ant.design/docs/react/use-with-create-react-app-cn" target="_blank" rel="noopener">create-react-app配置</a></p><blockquote><p>npm i react-app-rewired customize-cra -D</p></blockquote><p>然后修改 page.json</p><p>然后在项目根目录创建一个 config-overrides.js 用于修改默认配置。</p><blockquote><p>npm i babel-plugin-import -D<br>使用 babel-plugin-import后修改 config-overrides.js</p></blockquote><p>使用Antd自定义主题需要先安装 less less-loader 因为 Antd 样式文件使用less开发</p><blockquote><p>npm i less less-loader -s</p></blockquote><pre><code class="js">const { override, fixBabelImports, addDecoratorsLegacy, addLessLoader } = require(&quot;customize-cra&quot;);module.exports = override(  fixBabelImports(&quot;import&quot;, { //antd按需加载     libraryName: &quot;antd&quot;,    libraryDirectory: &quot;es&quot;,    style: &quot;css&quot;,    style: true  }),  addDecoratorsLegacy(),   // 配置装饰器  addLessLoader({   // Antd 自定义主题设置    javascriptEnabled: true,    modifyVars: { &#39;@primary-color&#39;: &#39;#1DA57A&#39; },  }),);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-入门笔记&quot;&gt;&lt;a href=&quot;#React-入门笔记&quot; class=&quot;headerlink&quot; title=&quot;React 入门笔记&quot;&gt;&lt;/a&gt;React 入门笔记&lt;/h1&gt;&lt;h2 id=&quot;React-应用创建方法&quot;&gt;&lt;a href=&quot;#React-应用创
      
    
    </summary>
    
      <category term="技术" scheme="http://blog.hjiya.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题思考汇总（Node篇）</title>
    <link href="http://blog.hjiya.cn/2020/03/21/interview1/"/>
    <id>http://blog.hjiya.cn/2020/03/21/interview1/</id>
    <published>2020-03-21T05:23:03.000Z</published>
    <updated>2020-03-26T04:01:34.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-node是单线程还是多线程"><a href="#1-node是单线程还是多线程" class="headerlink" title="1. node是单线程还是多线程"></a>1. node是单线程还是多线程</h2><p>Node是单线程的，但Node能开启多进程</p><h2 id="2-那Node怎么开启多线程"><a href="#2-那Node怎么开启多线程" class="headerlink" title="2. 那Node怎么开启多线程"></a>2. 那Node怎么开启多线程</h2><p>可以使用Node里的内置模块 <code>Cluster</code> 开启多进程</p><p>下面来看段代码</p><pre><code class="js">const cluster = require(&#39;cluster&#39;)const os = require(&#39;os&#39;)const numCPUs = os.cpus().lengthconst process = require(&#39;process&#39;)console.log(&#39;numCPUs&#39;,numCPUs)const workers = {}if(cluster.isMaster){  cluster.on(&#39;death&#39;, function(worker){    worker = cluster.fork()    workers[worker.pid] = worker  })  // 主进程  for(let i=0;i&lt;numCPUs;i++){    const worker = cluster.fork()    workers[worker.pid] = worker  }  // 当进程被终止  process.on(&#39;SIGTERM&#39;, function(){    for(let pid in workers){      process.kill(pid)    }    process.exit(0)  })} else {  // 其他进程，工作进程  const app = require(&#39;./app&#39;)  app.use(async (ctx,next) =&gt; {    console.log(&#39;worker&#39; + cluster.worker.id + &#39;,PID: &#39; + process.pid)    next()  })  app.listen(3000,() =&gt; {    console.log(&#39;http://127.0.0.1:3000&#39;)  })}</code></pre><h2 id="3-这里都是监听了统一端口，他们会冲突吗？"><a href="#3-这里都是监听了统一端口，他们会冲突吗？" class="headerlink" title="3. 这里都是监听了统一端口，他们会冲突吗？"></a>3. 这里都是监听了统一端口，他们会冲突吗？</h2><ul><li>并不会冲突，简单的说<ul><li>在服务器同时启动多个进程。</li><li>每个进程都跑的是同一份源码（好比把以前一个进程的工作分给多个进程去做）</li><li>更神奇的是，这些进程可以同时监听一个端口</li></ul></li><li>其中<ul><li>启动其他进程的叫做Master进程，他好比是个包工头，不做具体的工作，只负责启动其他进程</li><li>其他被Master启动的叫做Worker进程，顾名思义就是干活的工人，它们接受请求，对外提供服务</li><li>Woker进程数量一般工具服务器的CPU决定，这样就可以利用多核资源</li></ul></li></ul><h2 id="4-那它们是怎么调度的"><a href="#4-那它们是怎么调度的" class="headerlink" title="4. 那它们是怎么调度的"></a>4. 那它们是怎么调度的</h2><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-node是单线程还是多线程&quot;&gt;&lt;a href=&quot;#1-node是单线程还是多线程&quot; class=&quot;headerlink&quot; title=&quot;1. node是单线程还是多线程&quot;&gt;&lt;/a&gt;1. node是单线程还是多线程&lt;/h2&gt;&lt;p&gt;Node是单线程的，但Node能
      
    
    </summary>
    
      <category term="技术" scheme="http://blog.hjiya.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Birthday</title>
    <link href="http://blog.hjiya.cn/2020/03/21/birthday/"/>
    <id>http://blog.hjiya.cn/2020/03/21/birthday/</id>
    <published>2020-03-21T02:47:04.000Z</published>
    <updated>2020-03-21T04:19:58.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>闲来无事，搭个博客吧，也不知道写些啥，那就记录下我那平淡无奇的生活吧。</p><a href="http://blogpic.hjiya.cn/wallhaven-725842.webp" data-fancybox="images" data-caption="主人没有描述我哦~" target="_blank" rel="noopener"><img src="http://blogpic.hjiya.cn/wallhaven-725842.webp"></a><p><img src alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;闲来无事，搭个博客吧，也不知道写些啥，那就记录下我那平淡无奇的生活吧。&lt;/p&gt;
&lt;a href=&quot;http://blogpic.hjiya.
      
    
    </summary>
    
      <category term="随想" scheme="http://blog.hjiya.cn/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="悦读" scheme="http://blog.hjiya.cn/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
</feed>
