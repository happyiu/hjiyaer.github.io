{"meta":{"title":"咦~被你发现咯","subtitle":"嘻嘻","description":"愿你出走半生仍是少年","author":"ERYORE","url":"http://blog.hjiya.cn"},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"http://blog.hjiya.cn/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"about","date":"2020-03-20T14:14:36.000Z","updated":"2020-03-20T08:55:49.153Z","comments":false,"path":"about/index.html","permalink":"http://blog.hjiya.cn/about/index.html","excerpt":"","text":"[猫になりたいの明明就] 与&nbsp; 明明就&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-20T03:19:20.169Z","comments":true,"path":"comment/index.html","permalink":"http://blog.hjiya.cn/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"http://blog.hjiya.cn/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-20T08:51:25.813Z","comments":false,"path":"lab/index.html","permalink":"http://blog.hjiya.cn/lab/index.html","excerpt":"","text":"sakura主题暂未开放","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-20T05:45:36.428Z","comments":false,"path":"music/index.html","permalink":"http://blog.hjiya.cn/music/index.html","excerpt":"","text":"我的喜欢先别说不喜欢嘛，听多了也就习惯了鸭","keywords":"喜欢的音乐"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"http://blog.hjiya.cn/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-20T03:58:51.531Z","comments":true,"path":"links/index.html","permalink":"http://blog.hjiya.cn/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"http://blog.hjiya.cn/rss/index.html","excerpt":"","text":""},{"title":"悦读2","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-20T09:09:13.433Z","comments":true,"path":"tags/index.html","permalink":"http://blog.hjiya.cn/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"http://blog.hjiya.cn/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://blog.hjiya.cn/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"微信小程序云开发","slug":"wxxcxcloud","date":"2020-03-30T03:31:18.000Z","updated":"2020-03-30T03:33:52.875Z","comments":true,"path":"2020/03/30/wxxcxcloud/","link":"","permalink":"http://blog.hjiya.cn/2020/03/30/wxxcxcloud/","excerpt":"","text":"微信小程序云开发什么是微信小程序云开发？微信小程序 + 云（云函数（相当于一个后端服务）+ 云数据库）开发… 好吧，重点就在这个云开发上啦，它弱化了后端和运维概念，无需搭建服务器，使用微信提供的云服务就能完成后端和运维的搭建。 目录结构首先来瞅瞅微信小程序云开发项目的大致目录结构吧 . ├── cloudfunctions // 云函数文件目录 ├── book // 这里就放置一些云函数项目├── miniprogram // 这个文件夹里存放的就是正常的小程序项目了├── project.config.json // 项目的配置文件 需要注意的一点是：project.config.json 特殊的配置 { // 这里定义的对应上面的目录名称 &quot;cloudfunctionRoot&quot;: &quot;cloudfunctions/&quot;, &quot;miniprogramRoot&quot;: &quot;miniprogram/&quot;, } 项目结构并不复杂，就是将传统的小程序项目放入miniprogram 这个单独的文件夹中，再创建另外的一个文件夹来存放云函数。 那么接下来就来实现一个简单的小程序的云开发吧 实践这里呢我们就完成一个简单的小程序吧，这个小程序呢就只有一个页面（简单吧，哈哈哈哈） 主要涉及的功能有： 调用手机摄像头，扫描图书条形码 然后从豆瓣上通过爬虫获取到图书信息 将图书信息存入数据库 页面再从数据库中读取渲染出来 然后就再做个分页的功能吧，上拉触底后加载下一页 就这些功能，超简陋的demo，但麻雀虽小五脏俱全。 下面直奔主题 小程序页面布局页面布局的话，怎么简单怎么来好吧… look先就这样简单的布局下吧 接下来再来看看js部分 逻辑编写 那首先我们先来创建数据库，然后渲染出数据吧 创建数据库的步骤在 微信开发者工具—云开发—数据库中创建即可 要使用数据库里的数据首先要初始化，如下 // home.js // 初始化数据库 let db = wx.cloud.database() Page({ /** * 页面的初始数据 */ data: { books: [], page: 0, }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { this.getBooksList() // 将读取数据的方法封装成一个函数，方便复用 }, getBooksList(){ // 读取数据库，并将数据存入data const limit = 3 // 分页操作，表示一页显示几条数据 wx.showLoading() db.collection(&#39;books&#39;) // 表示要用哪张表 .orderBy(&#39;create_time&#39;, &#39;desc&#39;) // 简单的排序 .skip(this.data.page*limit) // 跳过前n页 .limit(limit) // 每次拿取n条 .get({ // 查询 success: res =&gt; { // console.log(res) if(res.data.length == 0){ this.setData({ isBottom: true }) } let newBooks = res.data.map(v =&gt; { // 简单的将查询结果做个处理 const rate = Math.round(v.rate / 2) v.rateDisplay = &quot;★★★★★☆☆☆☆☆&quot;.slice(5 - rate, 10- rate) return v }) if (this.data.page == 0) { // 如果是第一页就拉取第一页的数据 this.setData({ books: newBooks }) } else { this.setData({ // 因为要有分页效果，所以这里要把新数据拼接上老数据 books: [...this.data.books, ...newBooks] }) } wx.hideLoading() } }) }, 那么这样就完成了从数据库拿取数据啦 其次我们想点击调出摄像头，解析条形码，然后调用云函数去爬取豆瓣读书的数据 // home.wxml // 给 button 绑定一个事件吧 &lt;button class=&quot;btn&quot; type=&quot;primary&quot; bindtap=&quot;scanQR&quot;&gt;扫书&lt;/button&gt; // home.js // 初始化数据 let db = wx.cloud.database() Page({ /** * 页面的初始数据 */ data: { books: [] }, // 点击扫书触发的事件 scanQR(){ wx.scanCode({ success: res =&gt; { // console.log(res.result) wx.showLoading() wx.cloud.callFunction({ // call调用云函数 ————&gt; 可看下一部分代码 name: &#39;bookfn&#39;, // 这里要触发哪个云函数 data: { // 传参 isbn: res.result, }, success: ({result}) =&gt; { // 成功的回调 // console.log(result) result.create_time = new Date().getTime() // 添加一个扫书时间 // 将爬取豆瓣的信息存入数据库 db.collection(&#39;books&#39;).add({ data: result, success: ret =&gt; { wx.hideLoading() if(ret._id){ wx.showModal({ title: &#39;提示信息&#39;, content: `《${result.title}》添加添加成功` }) this.getBooksList() } } }) } }) } }) }, 上面就是点击扫书的逻辑啦，然后重点是调用了下面的云函数 // cloudfunctions/bookfn/index.js // 云函数入口文件 const cloud = require(&#39;wx-server-sdk&#39;) const axios = require(&#39;axios&#39;) const doubanbook = require(&#39;doubanbook&#39;) const cheerio = require(&#39;cheerio&#39;) cloud.init() async function getDoubanBool(isbn) { // 这是豆瓣url规则 let url = &#39;https://search.douban.com/book/subject_search?search_text=&#39; + isbn // 请求豆瓣数据 let res = await axios.get(url) // 创建正则 用来匹配 加密的图书信息 let reg = /window\\.__DATA__ = &quot;(.*)&quot;/ // 正则匹配加密的字符串 if(reg.test(res.data)){ // 解密 let searchData = doubanbook(RegExp.$1)[0] return searchData } } // getDoubanBool(9787121349126) // 云函数入口函数 exports.main = async (event, context) =&gt; { let { isbn } = event let bookInfo = await getDoubanBool(isbn) // 获取book的详情页 let detailPage = await axios.get(bookInfo.url) // 解析页面来获取指定的内容 let $ = cheerio.load(detailPage.data) const summary = $(&quot;#link-report .intro&quot;).text() return { bid: bookInfo.id, title: bookInfo.title, rate: bookInfo.rating.value, image: bookInfo.cover_url, summary } } 然后我们最后再处理下触底刷新吧 onReachBottom: function () { this.setData({ page: this.data.page + 1 // 将当前页数加1 }) this.getBooksList() // 从数据库拉取新数据 }, 至此，扫书的小Demo就完成啦，然后我们再按喜好改改页面就ok了，就让我们看看效果图吧","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.hjiya.cn/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://blog.hjiya.cn/categories/技术/"}]},{"title":"UmiJs","slug":"umi","date":"2020-03-28T12:01:48.000Z","updated":"2020-03-28T12:16:10.002Z","comments":true,"path":"2020/03/28/umi/","link":"","permalink":"http://blog.hjiya.cn/2020/03/28/umi/","excerpt":"","text":"Umi安装 全局安装 Umi 推荐使用 yarn 代替 npm 来安装 umi ， yarn 会针对部分场景做一些缓存以节省时间，你可以输入以下命令来全局安装 yarn，使用yarn后项目中尽量避免再使用npm，不然可能会发生意想不到的错误。 # 使用 yarn 安装 Umi yarn global add umi # 查看 Umi 版本 umi --version Umi 快速搭建项目创建进入目录后，使用终端工具输入 # 脚手架工具，快速搭建项目 yarn create umi 选择项目类型 这里我选择了 ant-design-pro ~ ? Select the boilerplate type (Use arrow keys) ant-design-pro - Create project with an layout-only ant-design-pro boilerplate, use together with umi block. ❯ app - Create project with a simple boilerplate, support typescript. block - Create a umi block. library - Create a library with umi. plugin - Create a umi plugin. 然后选择是否使用 TypeScript，推荐使用TypeScript，输入y后回车结束 看喜好吧，ts不太熟，直接js了 ? Do you want to use typescript? (y/N) 项目创建完成# 启动项目 yarn start / umi dev 项目结构分析. ├── config ├── config.js // ** 包含项目的基本配置，如果插件，路由配置 ├── proxy.js // 前端代理 ├── mock // mock数据 ├── node_modules ├── dist // 打包输出 ├── public ├── src ├── assets // 静态资源 ├── *components // 公共组件 自己创建 ├── layouts // 全局页面布局 ├── models // saga models放全局的 ├── pages/ // router页面 umi约定名称 ├── document.ejs // HTML template ├── helloworld.jsx // 页面，导出react组件 ├── *services // 接口 自己创建 ├── *utils // 全局方法 自己创建 ├── locales // ** 语言配置，Menu配置等 ├── global.less ├── tests ├── package.json ... ... 接下来看看Umi的基本使用吧 ——&gt; Umi基本使用如何创建页面？ 使用终端工具输入命令 # 在page目录下 创建 channel 文件夹并在里面创建index.js文件，并初始化css文件为 less 格式 umi g page channel/index --less 当然也可以直接创建文件或文件夹的形式创建页面 路由配置接下来我们配置一下路由 // config/config.js 中注册 路由 routes: [ ... ... + { + name: &#39;channel&#39;, + icon: &#39;table&#39;, + path: &#39;/channel&#39;, + component: &#39;./channel&#39; + }, ... ... ] 以上我们就配置好了路由，在地址栏直接输入 /channel 就可以访问了 这里我们用到了 Antd 的框架。所以，我们配置好的路由就会出现在侧边栏上啦 但是channel怎么显示为中文呢？那么来看看怎么配置 侧边导航栏 // .src/locales/zh-CN/menu.js // 我们可以在这个文件中手动的配置我们的侧边导航栏 export default { &#39;menu.welcome&#39;: &#39;欢迎&#39;, &#39;menu.channel&#39;: &#39;渠道&#39;, &#39;menu.more-blocks&#39;: &#39;更多区块&#39;, &#39;menu.home&#39;: &#39;首页&#39;, + &#39;menu.channel&#39;: &#39;频道&#39; // 以 menu.name 的形式来配置 ... ... }; 就此，我们就可以就此来写一个简单的Demo了。 查询表格Demo这里我们就简单的编写个查询表格的Demo吧 页面编写首先我们先将页面布局来整整吧，页面布局很简单，直接上代码 import React, { Component } from &#39;react&#39;; import styles from &#39;./index.less&#39;; import { PageHeaderWrapper } from &#39;@ant-design/pro-layout&#39;; import { Form, Input, Card, Table, Button } from &#39;antd&#39; let columns = [ { title: &#39;姓名&#39;, dataIndex: &#39;name&#39;, key: &#39;name&#39;, }, { title: &#39;年龄&#39;, dataIndex: &#39;age&#39;, key: &#39;age&#39;, }, { title: &#39;城市&#39;, dataIndex: &#39;city&#39;, key: &#39;city&#39;, }, ] class Channel extends Component { render() { return ( &lt;PageHeaderWrapper&gt; &lt;div&gt; &lt;Card className={styles.channel}&gt; &lt;Form&gt; &lt;Form.Item label=&quot;姓名&quot;&gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Button type=&quot;primary&quot; &gt;搜索&lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/Card&gt; &lt;Card&gt; &lt;Table dataSource={[]} columns={columns} /&gt; &lt;/Card&gt; &lt;/div&gt; &lt;/PageHeaderWrapper&gt; ) } } export default Channel 来看下效果图 ojbk，接下来先把表格的数据渲染出来吧 渲染表格数据这里呢，大致的逻辑就是： 首先发送请求拿取数据， 然后存放到redux中， 页面到redux中获取数据， 最后渲染即可。 那么我们这里Umi里集成好了dva，那我们就直接使用dva来代替原生的redux了 // src/models/channel.js import { getChannelDataAJAX } from &#39;../services/channel&#39; const Model = { namespace: &#39;channel&#39;, // 命名空间 state: { // 该Model当前的状态，数据都存着 data: [] }, effects: { // 请求数据，处理异步，里面都是Generator函数 *getChannelData({payload}, {call, put}) { // getChannelDataAJAX 就是个封装好的AJAx请求 const res = yield call(getChannelDataAJAX, payload) // call执行异步函数 yield put({type: &#39;channelData&#39;, payload: res}) // put发出一个Action }, }, reducers: { // 更新数据，Action处理器，处理同步动作，更新State状态 channelData(state, {payload}){ // 对应 put({type: &#39;channelData&#39;) return {...state, data: [...payload.data]} // 更新 State 的状态 }, } } export default Model 到此，我们请求好了数据并放在了redux上啦，接下来我们让页面获取到redux里的数据就ok了 页面想要获取redux里的数据我们可以使用 connect 连接redux 先看最后一段的 connect 连接 import React, { Component } from &#39;react&#39;; import styles from &#39;./index.less&#39;; import { PageHeaderWrapper } from &#39;@ant-design/pro-layout&#39;; import { Form, Input, Card, Table, Button } from &#39;antd&#39; import { connect } from &#39;dva&#39;; let columns = [ ... ... ] class Channel extends Component { componentDidMount(){ // console.log(this.props) this.props.getChannelData() // 3. 页面挂载后，请求数据，保存入redux } render() { let { data } = this.props // 4. 获取到挂载到this.props上的data，并解构出来 return ( &lt;PageHeaderWrapper&gt; &lt;div&gt; &lt;Card className={styles.channel}&gt; &lt;Form&gt; &lt;Form.Item label=&quot;姓名&quot;&gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Button type=&quot;primary&quot;&gt;搜索&lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/Card&gt; &lt;Card&gt; {/* 5. 然后这里就可以直接渲染出来啦 */} &lt;Table dataSource={data} columns={columns} /&gt; &lt;/Card&gt; &lt;/div&gt; &lt;/PageHeaderWrapper&gt; ) } } export default connect( // 1. mapStateToProps 将 redux里的state映射到this.props上 // {channel} 就表示 state.channel =&gt; ({...channel}) ({channel}) =&gt; ({...channel}), // 2. mapReducerToProps 将dispatch的方法映射到this.props上 { getChannelData: () =&gt; ({type: &#39;channel/getChannelData&#39;}) } )(Channel) Look，数据渲染出来啦。 接下来就继续实现搜索这个小功能吧 搜索功能搜索功能大致的逻辑： 首先在输入框输入要搜索的关键字 输入完后触发方法，发送请求到后端 请将响应的结果返回，并更新redux即可 那首先来看看dva里的Model内容吧，整个搜索的逻辑和首次获取数据类似 import { getChannelData, getChannelDataBySearchAJAX} from &#39;../services/channel&#39; const Model = { namespace: &#39;channel&#39;, state: { data: [] }, effects: { *getChannelData({payload}, {call, put}) { const res = yield call(getChannelData, payload) yield put({type: &#39;channelData&#39;, payload: res}) }, // 这里是触发搜索的时候发送的异步操作 *getChannelDataBySearch({payload}, {call, put}){ // console.log(payload) // getChannelDataBySearchAJAX 发送搜索的AJAX const res = yield call(getChannelDataBySearchAJAX, payload) // console.log(res) // 触发 reducers 中的 channelDataBySearch yield put({type: &#39;channelDataBySearch&#39;, payload: res}) } }, reducers: { channelData(state, {payload}){ return {...state, data: [...payload.data]} }, // 将获取到的结果做个更新 channelDataBySearch(state, {payload}){ return {...state, data: [...payload.data]} } } } export default Model 然后我们最后来看看页面怎么处理的吧 因为有个输入框，所以我们要将输入的内容保存下来 并且输入的内容改变时触发this.setState()来修改State里的数据 给Button按钮绑定方法可以dispatch import React, { Component } from &#39;react&#39;; import styles from &#39;./index.less&#39;; import { PageHeaderWrapper } from &#39;@ant-design/pro-layout&#39;; import { Form, Input, Card, Table, Button } from &#39;antd&#39; import { connect } from &#39;dva&#39;; let columns = [... ...] class Channel extends Component { constructor(props){ super(props) this.state = { name: &#39;&#39; // 1. 输入的内容保存在这里哦 } } componentDidMount(){ // console.log(this.props) this.props.getChannelData() } setName = (event) =&gt; { // 2. 这是修改 state里name的方法 this.setState({ name: event.target.value }) } search = () =&gt; { // 触发搜索的dispatch方法 const { name } = this.state // console.log(name) this.props.getChannelDataBySearch(name) } render() { let { data } = this.props const { name } = this.state return ( &lt;PageHeaderWrapper&gt; &lt;div&gt; &lt;Card className={styles.channel}&gt; &lt;Form&gt; &lt;Form.Item label=&quot;姓名&quot;&gt; {/* 绑定value，以及修改state状态的方法 */} &lt;Input value={name} onChange={this.setName} /&gt; &lt;/Form.Item&gt; &lt;Form.Item&gt; {/* 绑定 触发搜索的方法 */} &lt;Button type=&quot;primary&quot; onClick={this.search}&gt;搜索&lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/Card&gt; &lt;Card&gt; &lt;Table dataSource={data} columns={columns} rowKey={({id}) =&gt; id} /&gt; &lt;/Card&gt; &lt;/div&gt; &lt;/PageHeaderWrapper&gt; ) } } export default connect( ({channel}) =&gt; ({...channel}), { getChannelData: () =&gt; ({type: &#39;channel/getChannelData&#39;}), // 3. dispatch的方法 getChannelDataBySearch: (name) =&gt; ({type: &#39;channel/getChannelDataBySearch&#39;, payload: {name}}) } )(Channel) 唔，就此，搜索功能完成啦 好了，这就是个小小的Demo，用来初探Umi~","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.hjiya.cn/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://blog.hjiya.cn/categories/技术/"}]},{"title":"react","slug":"react","date":"2020-03-26T02:58:19.000Z","updated":"2020-03-26T03:44:11.303Z","comments":true,"path":"2020/03/26/react/","link":"","permalink":"http://blog.hjiya.cn/2020/03/26/react/","excerpt":"","text":"React 入门笔记React 应用创建方法使用 create react app 脚手架命令快速创建 React应用 npx create-react-app name 简单使用在 index.js 中渲染上页面的核心代码 import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; // 创建了一个简单的React元素 const app = &lt;h1&gt;Welcome React&lt;/h1&gt; ReactDOM.render( app, document.querySelector(&#39;#root&#39;) ) 创建组件使用函数创建组件const App = (props) =&gt; { return ( &lt;div&gt; &lt;h1&gt;welcome {props.title}&lt;/h1&gt; &lt;/div&gt; ) } ReactDOM.render( &lt;App title=&quot;1901&quot;/&gt;, document.querySelector(&#39;#root&#39;) ) Class类创建组件import React from &#39;react&#39; import {render} from &#39;react-dom&#39; // 定义组件的第二种方式 --&gt; 类 class App extends React.Component { render(){ return ( &lt;div&gt; &lt;h1&gt;Welcome React {this.props.title}&lt;/h1&gt; &lt;/div&gt; ) } }; render( &lt;App title=&#39;2019&#39;/&gt;, document.querySelector(&#39;#root&#39;) ); // 底层原理 // &lt;App title=&quot;2019&quot; /&gt; 编译成以下代码 // const app = new App({ // title: &quot;2019&quot; // }).render() jsx 原理虚拟DOM树方式 React.createElemet(type,[props],[…children]) 是一个方法，用于创建元素，参数：（标签名，标签属性，子元素…） // class App extends Component { // render(){ // return ( // &lt;div&gt; // &lt;h1&gt;Welcome React&lt;/h1&gt; // &lt;/div&gt; // ) // } // } // 底层编译为 以下方式 class App extends Component { render(){ return ( React.createElement( &#39;div&#39;, { className: &#39;dv1&#39;, id: &#39;appRoot&#39; }, React.createElement( &#39;h1&#39;, { className: &#39;title&#39;, }, &#39;Welcome React&#39; ) ) ) } } 样式类名的绑定 内联样式创建 使用 styled-components 插件 定义样式组件，再使用样式组件包裹 使用 className 的方法直接添加 类名 使用 classnames 插件，动态添加 类名 // 定义样式组件 const Title = styled.h1` color: red ` const Header = () =&gt; &lt;h1&gt;hi&lt;/h1&gt; // 定义组件的第二种方式 --&gt; 类 class App extends Component { render(){ // 使用内联样式创建 const style = {color: &quot;red&quot;} return ( &lt;div&gt; &lt;Header /&gt; &lt;h1 style={style}&gt;Welcome React {this.props.title}&lt;/h1&gt; {/* 使用 className 方式 注意这里样式类名需要 className 而不是 class */} &lt;h1 className=&quot;has-test-pink&quot;&gt;Welcome React {this.props.title} 2&lt;/h1&gt; {/* 使用 classnames 插件 绑定动态样式 */} &lt;h1 className={classNames(&#39;a&#39;,{&#39;has-test-pink&#39;: true})}&gt;Welcome React {this.props.title} 3&lt;/h1&gt; {/* 使用定义好的样式组件 */} &lt;Title className={classNames(&#39;a&#39;,{&#39;has-test-pink&#39;: true})}&gt;Welcome React {this.props.title} 4&lt;/Title&gt; &lt;/div&gt; ) } } 向子组件传值做类型检查prop-types 函数组件的类型检查方法 &lt;TodoHeader title=&quot;代办事项&quot; x={1} y={2}&gt; hi &lt;/TodoHeader&gt; TodoHeader.propTypes = { title: PropTypes.string, x: PropTypes.number.isRequired, // 这里可以链式操作 y: PropTypes.number, } 类组件的类型检查方法 &lt;TodoInput btnText=&quot;添加吧&quot;/&gt; export default class TodoInput extends Component { // 静态属性 static propTypes = { btnText: PropTypes.string } render() { return ( &lt;div&gt; &lt;input /&gt;&lt;button&gt;{this.props.btnText}&lt;/button&gt; &lt;/div&gt; ) } } 子组件传参设置默认值 函数组件设置默认值TodoHeader.defaultProps = { title: &#39;Welcome&#39; } 类组件设置默认值export default class TodoInput extends Component { static propTypes = { btnText: PropTypes.string } static defaultProps = { btnText: &#39;添加&#39; } render() { return ( &lt;div&gt; &lt;input /&gt;&lt;button&gt;{this.props.btnText}&lt;/button&gt; &lt;/div&gt; ) } } 组件自己的数据状态class 类组件 -有状态组件function 函数组件 -无状态组件（Hook有解决办法） 使用 this.state.name 来获取数据 state 只有 class类组件才会有 export default class App extends Component { // 方法一 // state = { // title: &#39;代办事项App&#39; // } // 方法二 constructor(){ super() this.state = { title: &#39;待办事项App&#39; } } render() { return ( &lt;Fragment&gt; &lt;TodoHeader title={this.state.title} x={1} y={2}&gt; hi &lt;/TodoHeader&gt; &lt;TodoInput btnText=&quot;添加吧&quot;/&gt; &lt;TodoList /&gt; {this.state.title} &lt;/Fragment&gt; ) } } 渲染数据 直接渲染{this.state.name} html文本渲染(Vue中的v-html) &lt;div dangerouslySetInnerHTML={{__html: this.state.htxt}} /&gt; 列表渲染 this.props.todos.map(item=&gt;{ return ( &lt;TodoItem key={item.id} {...item} /&gt; ) }) 修改数据使用 this.setState() 的方法来修改数据 this.setState() 需要两个参数 第一个参数又有两种情况第一种情况是一个对象： handleLikeClick = () =&gt; { // 需要使用 setState 修改数据 this.setState({ isLike: !this.state.isLike }) } 第二种情况是一个方法： 方法中有个参数，保存着修改数据前的数据 this.setState((prev)=&gt;{ console.log(prev) return { isLike: !this.state.isLike } }) 第二个参数为一个回调函数，来获取最新的数据状态this.setState((prev)=&gt;{ console.log(prev) return { isLike: !this.state.isLike } },()=&gt;{ console.log(this.state.isLike) }) setState 特性 setState是异步操作 ⽤setState更新状态⽽不能直接修改 this.state.counter += 1; //错误的 且setState是批量执行的，因此对同一个状态执行多次只起一次作用，多个状态更新可以放在同一个setState中进行 componentDidMount(){ this.setState({counter: this.state.counter + 1}); this.setState({counter: this.state.counter + 1}); this.setState({counter: this.state.counter + 1}); } // 最后 Counter的值为 1 （setState只有在合成事件和钩⼦子函数中是异步的，在原生事件和setTimeout、setInterval中都是同步的） 使其同步的方法 第一种方法 如上this.setState() 传入回调函数 第二种方法就是原生事件 componentDidMount(){ document.getElementsByTagName(&#39;button&#39;)[0].addEventListener(&#39;click&#39;, () =&gt; { this.setState({ counter: this.state.counter + 2 }) }) } 第三种就是定时器 handleLikeClick = () =&gt; { setTimeout(() =&gt; { this.setState({ counter: this.state.counter + 1 }) }, 0); } 事件onClick，onChange…. 方法一 &lt;input onChange={this.handleInputChange} type=&quot;text&quot; value={this.state.inputValue}/&gt; handleInputChange = (e)=&gt; { this.setState({ inputValue: e.currentTarget.value }) } 方法二：可以传递参数 &lt;button onClick={this.handleClick.bind(this,123)}&gt;{this.props.btnText}&lt;/button&gt; handleClick(num){ console.log(this.state.inputValue,num) } 事件传参 外面再包层匿名函数，因为使用这种事件是匿名函数，渲染的时候就会自动执行，所以外面再加层匿名函数 &lt;button onClick={() =&gt; { this.handleBtnClick(123) }}&gt;事件传参&lt;/button&gt; 使用.bind(this,参数列表) hook 钩子函数hook 钩子函数可以使 函数组件也能拥有 类组件中自己的状态和其他特性 // 需要导入 useState useEffect hook来完成操作 import React, { useState, useEffect } from &#39;react&#39; export default function User() { // const date = new Date() const [date, setDate] = useState(new Date()) // 一个变量定义一次 useEffect(() =&gt; { const timeid = setInterval(() =&gt; { setDate(new Date()) }, 1000) return () =&gt; clearInterval(timeid) }) return ( &lt;div&gt; &lt;h1&gt;{date.toLocaleTimeString()}&lt;/h1&gt; &lt;/div&gt; ) } 组件通讯props// 父组件 &lt;Search store={store} title=&quot;props&quot; tellme={tellme} /&gt; // 子组件 // this.props.title this.props.tellme 的形式来接收 createContext 是 react 提供的跨组件的方法createContext 这个方法的结果是一个对象，里面有2个组件，Provider和Consumer Provider 用于提供状态 Consumer 用于接收状态 // 想解构出来 const { Provider, Consumer:CounterConsumer } = createContext() class CounterProvider extends Component { constructor(){ super() // 这里的状态是共享的，任何CounterProvider的子孙组件，都可以使用CounterConsumer来接收 this.state = { count: 100 } } // 这里的方法也会继续通过Provider共享下去 incrementCount = () =&gt; { this.setState({ count: this.state.count + 1 }) } decrementCount = () =&gt; { this.setState({ count: this.state.count - 1 }) } render(){ return ( // 使用 Provider 这个组件 ，必须有个value值，这个Value中科院传递任何的数据，一般传递一个对象 &lt;Provider value={{count: this.state.count, onIncrementCount: this.incrementCount, onDecrementCount:this.decrementCount}}&gt; {this.props.children} &lt;/Provider&gt; ) } } // 定义的子孙组件，使用 CounterConsumer 来接收count class Counter extends Component { render(){ return ( &lt;CounterConsumer&gt; { //注意，这里的CounterConsumer包裹着的必须是一个方法， //参数是Provider提供的Value ({count}) =&gt; { return &lt;span&gt;{count}&lt;/span&gt; } } &lt;/CounterConsumer&gt; ) } } HOC 高阶组件 Height-order component可以劫持页面渲染 // App.js import React, { Component } from &#39;react&#39; // 导入 高阶组件 import witCopyright from &#39;./witCopyright&#39; class App extends Component { render(){ return ( &lt;div&gt; &lt;h1&gt;h&lt;/h1&gt; &lt;/div&gt; ) } } // 使用高阶组件，并将 App 组件 作为参数传入 export default witCopyright(App) // 高阶组件 witCopyright.js import React, { Component } from &#39;react&#39; const witCopyright = (YourComponent) =&gt; { return class witCopyright extends Component { render() { return ( &lt;&gt; 这里就是 刚才传入函数，将其使用 这里注意 要使用 {...this.props} 更改 props &lt;YourComponent {...this.props}/&gt; &lt;div&gt;&amp;copy; 2019 &amp;emsp; 黄即呀&lt;/div&gt; &lt;/&gt; ) } } } export default witCopyright 使用装饰器 装饰高阶组件的写法安装包 第一步 npm i react-app-rewired –sava-dev 然后修改 page.json 文件，修改为 react-app-rewired &quot;scripts&quot;: { &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; } 然后再 项目目录下创建一个 config-overrides.js 即可 // config-overrides.js module.exports = (config) =&gt; { // 在这里可以对 config 进行配置 return config } 第二步 安装 customize-cra 来方便定义配置项 npm i customize-cra –sava-dev 修改 config-overrides.js const {override,addDecoratorsLegacy} = require(&#39;customize-cra&#39;) module.exports = override( addDecoratorsLegacy() ) npm i @babel/plugin-proposal-decorators -D 状态管理 redux 手动连接手动实现 redux 状态管理简单的redux的实现 ， 详情见 redux-pronciple-2.html const countState = { count: 5 } const changeState = (state,action) =&gt; { if(!state){ return countState } switch(action.type){ default: return state; case &quot;JIAN&quot;: return { ...state, count: state.count - action.n } break; case &quot;JIA&quot;: return { ...state, count: state.count + action.n } } } const createStore = (reducer) =&gt; { let state = null const getState = () =&gt; state const Listeners = [] const subScribe = (Listener) =&gt; Listeners.push(Listener) const dispatch = (action) =&gt; { state = changeState(state,action) Listeners.forEach(listener =&gt; listener()) } dispatch({}) return { getState, dispatch, subScribe } } const store = createStore(changeState) const renderCount = () =&gt; { countDisplay.innerHTML = store.getState().count } renderCount() store.subScribe(renderCount) 使用 redux 首先在 src目录下新建 2个 文件夹 reducers actions 然后在 src 目录下新建一个文件：store.js`jsimport { createStore } from ‘redux’// 导入 reducersimport rootReducer from ‘./reducers’ export default createStore(rootReducer) - 在reducers文件夹下新建一个 car.js 并导出 ```js const initState = [] export default (state = initState,action) =&gt; { switch(action.type){ default: return state } } 在reducers文件夹下新建一个 index.js 文件用来合并导出reducers中的其他文件`js// 用于合并多个 reducersimport { combineReducers} from ‘redux’import car from ‘./car’ export default combineReducers({ car}) `......太痛苦了......` ## 状态管理 React-redux 自动连接 - 创建 reducers - 合并 reducers - createStore - Provider store = { store } - connect(mapStateToProps,{...actionCreators})(YourComponent) - actionCreators - 修改reducers ### 首先创建 reducers 文件目录下的 reducer分类文件 ```js // 未来避免 actionType 重复，一般会把action放在文件里，统一管理 import actionType from &#39;../actions/actionType&#39; // 对于 购物车 来说，这里有个初始化的状态 const initState = [ { id: 1, title: &#39;Apple&#39;, price: 999, amount: 10 }, { id: 2, title: &#39;Orange&#39;, price: 99, amount: 6 } ] // 创建 购物车的 reducer ，是个纯函数，reducer的固定写法 两个参数 // 第一个参数是 state并有一个初始值 // 第二个参数是 action export default (state = initState,action) =&gt; { // 根据不同的 action 来处理不同的结果，每次返回新的state，返回的类型要一样 switch(action.type){ // 一定要有default ，当actionType 不对时候，就不做任何处理，返回上一次的state default: return state; case actionType.CAR_AMOUNT_INCREMENT: return state.map(item =&gt; { if(item.id === action.payload.id){ item.amount += 1 } return item }) case actionType.CAR_AMOUNT_DECREMENT: return state.map(item =&gt; { if(item.id === action.payload.id){ item.amount -= 1 } return item }) } } reducers目录下创建 index.js 合并多个 reducer 并导出由于在实际中，只有单一的store,但是状态会有很多分类，因此需要划分reducer，但createStore() 参数只接受一个reducer，所以redux提供了一个合并多个reducer的方法：combineReducers // 用于合并多个 reducers import { combineReducers} from &#39;redux&#39; // 引入 car reducer，如果有多个，继续引入 import car from &#39;./car&#39; // 导出合并后的 reducer export default combineReducers({ // 把多个 reducer作为 combineReducers 参数对象 传入，在外部就可以通过 store.getState().car 来获取到 carReducer里面的state car }) 创建 Action 目录，然后创建特定的 car.jsimport actionType from &#39;./actionType&#39; // action 有两种写法 // 一：写成一个对象，缺点不好传递参数 // export const increment = { // type: actionType.CAR_AMOUNT_INCREMENT // } // 二：写成一个方法，返回一个对象，这个对象才是真正的action export const increment = (id) =&gt; { return { type: actionType.CAR_AMOUNT_INCREMENT, payload:{ id } } } export const decrement = (id) =&gt; { return { type: actionType.CAR_AMOUNT_DECREMENT, payload:{ id } } } 在Action目录下创建 actionType 来统一管理 actionexport default { CAR_AMOUNT_INCREMENT: &#39;CAR_AMOUNT_INCREMENT&#39;, CAR_AMOUNT_DECREMENT: &#39;CAR_AMOUNT_DECREMENT&#39;, } 创建 store.js// createStore 是 redux用来创建store的方法 import { createStore } from &#39;redux&#39; // 引入合并后的 reducer import rootReducer from &#39;./reducers&#39; // createStore(rootReducer) 第一个参数必须是 一个reducer export default createStore(rootReducer) 最后使用放在应用程序最顶层，且必须有 store 属性import React from &#39;react&#39; import {render} from &#39;react-dom&#39; import App from &#39;./App&#39; import store from &#39;./store&#39; // Rrovier 是 react-redux 提供的一个组件 import { Provider } from &#39;react-redux&#39; render( // 这个store 的值，就是我们所创建的 store // 只要被 Producer 包裹的组件，所有的后代组件都可以使用Redux.connect做连接 &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.querySelector(&quot;#root&quot;) ) 子组件连接获取数据import React, { Component } from &#39;react&#39; // 导入 actionCreators import { increment,decrement } from &#39;../../actions/car&#39; // connect 执行后是一个高阶组件 import { connect } from &#39;react-redux&#39; class CarList extends Component { render() { return ( &lt;table&gt; &lt;tbody&gt; { this.props.carList.map(item =&gt; { return ( &lt;tr key={item.id}&gt; &lt;td&gt;{item.id}&lt;/td&gt; &lt;td&gt;{item.title}&lt;/td&gt; &lt;td&gt;{item.price}&lt;/td&gt; &lt;td&gt; &lt;button onClick={()=&gt;{ this.props.dispatch(decrement(item.id)) }}&gt;-&lt;/button&gt; &lt;span&gt;{item.amount}&lt;/span&gt; &lt;button onClick={()=&gt;{ this.props.dispatch(increment(item.id)) }}&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; ) }) } &lt;/tbody&gt; &lt;/table&gt; ) } } // 这里的 state 实际上就是 store.getState()的值 const mapStateToProps = (state) =&gt; { // 这里return了什么，组件中就可以this.props来获取 return { carList: state.car } } // connect方法常用的参数 // 第一个参数： mapStateToProps 作用就是从store里把state注入到当前组件props // 第二个参数：可以是mapDisPatchProps，这个主要作用就是将action生成的方法注入到单签组件的props // 直接第二个参数传递一个对象，里面的对象就是actionCrators，只要传入了，在组件中就可以通过this.props.actionCreator来调用 export default connect(mapStateToProps)(CarList) redux 处理 异步操作 需要一个中间件处理 npm install redux-thunk 先在 store 中传入applyMiddleware(thunk) export default createStore(rootReducer,applyMiddleware(thunk)) 然后在 actions 中导出以下代码 export const decrementAsync = id =&gt; dispatch =&gt; { setTimeout(() =&gt; { dispatch(decrement(id)) }, 1000); } 路由 React Router简单匹配Web 上安装只需要安装这一个就可以了 npm i react-router-dom -s 只需要在最顶层使用一次Router就可以了Router 只需要在最顶级使用一次就可以了 import React from &#39;react&#39; import {render} from &#39;react-dom&#39; import App from &#39;./App&#39; // 将 BrowserRouter 重命名为 Router ，方便调用 // HashRouter and BrowserRouter 可以选择 路由模式 // Route 组件相当于 Vue中 的 &lt;router-view&gt;&lt;/router-view&gt; import { BrowserRouter as Router,Route } from &#39;react-router-dom&#39; render( // 最顶层只需使用 Router 包裹一次就可以了 &lt;Router&gt; 使用 Route组件 来渲染组件 &lt;Route component={App}/&gt; &lt;/Router&gt;, document.querySelector(&quot;#root&quot;) ) 路由跳转import React, { Component } from &#39;react&#39; // 路由跳转需要使用到 Link 组件，相当于Vue中的,&lt;router-link&gt;&lt;/router-link&gt; // NavLink 作用和 Link 作用差不多，但 NavLink可以给链接自动添加一些属性 // Redirect 组件 负责 页面重定向 import { Route, Link, NavLink, Redirect } from &#39;react-router-dom&#39; import { Home, Artical, Users } from &#39;./views&#39; export default class App extends Component { render() { return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/artical&quot;&gt;文章&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=&quot;/users&quot;&gt;用户&lt;/NavLink&gt;&lt;/li&gt; &lt;/ul&gt; 页面重定向 &lt;Redirect to=&quot;/home&quot; from=&quot;/&quot;&gt;&lt;/Redirect&gt; &lt;Route component={Home} path=&quot;/home&quot; /&gt; &lt;Route component={Artical} path=&quot;/artical&quot; /&gt; &lt;Route component={Users} path=&quot;/users&quot; /&gt; &lt;/div&gt; ) } } 动态路由 点击链接后，链接不消失，在链接的页面上放置 artical.js import React, { Component } from &#39;react&#39; import { Link, Route } from &#39;react-router-dom&#39; import ArticalDetail from &#39;./ArticalDetail&#39; export default class Artical extends Component { render() { return ( &lt;div&gt; &lt;Link to=&quot;/artical/1&quot;&gt;文章一&lt;/Link&gt; &lt;Link to=&quot;/artical/2&quot;&gt;文章二&lt;/Link&gt; 这里设置 path=&quot;/artical/:id&quot; &lt;Route component={ArticalDetail} path=&quot;/artical/:id&quot; /&gt; &lt;/div&gt; ) } } 组件中 获取参数的方法 {this.props.match.params.id} 点击链接后链接消失,即将 放置值与连接页面同级的页面 App.js import React, { Component } from &#39;react&#39; import { Route, Link, NavLink, Redirect } from &#39;react-router-dom&#39; import { Home, Artical, Users, ArticalDetail } from &#39;./views&#39; export default class App extends Component { render() { return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/artical&quot;&gt;文章&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=&quot;/users&quot;&gt;用户&lt;/NavLink&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Redirect to=&quot;/home&quot;&gt;&lt;/Redirect&gt; &lt;Route component={Home} path=&quot;/home&quot; /&gt; 注意要加上 exact（完全匹配） &lt;Route component={Artical} path=&quot;/artical&quot; exact/&gt; &lt;Route component={ArticalDetail} path=&quot;/artical/:id&quot; /&gt; &lt;Route component={Users} path=&quot;/users&quot; /&gt; &lt;/div&gt; ) } } 处理 404import React, { Component } from &#39;react&#39; import { Route, Link, NavLink, Redirect, Switch } from &#39;react-router-dom&#39; import { Home, Artical, Users, ArticalDetail, NotFound } from &#39;./views&#39; export default class App extends Component { render() { return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/artical&quot;&gt;文章&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=&quot;/users&quot;&gt;用户&lt;/NavLink&gt;&lt;/li&gt; &lt;/ul&gt; 注意 需要使用 Switch 包裹，不然符合条件的都回去渲染 &lt;Switch&gt; &lt;Route component={Home} path=&quot;/home&quot; /&gt; &lt;Route component={Artical} path=&quot;/artical&quot; exact/&gt; &lt;Route component={ArticalDetail} path=&quot;/artical/:id&quot; /&gt; &lt;Route component={Users} path=&quot;/users&quot; /&gt; &lt;Route component={NotFound} path=&quot;/404&quot; /&gt; &lt;Redirect to=&quot;/home&quot; from=&quot;/&quot; exact /&gt; &lt;Redirect to=&quot;/404&quot; /&gt; &lt;/Switch&gt; &lt;/div&gt; ) } } 路由其他API使用 render(function) 俩代替 component={}优点，可以传递参数 &lt;Router&gt; 使用render使，里面要是个函数，其中有一个参数为 路由信息 使用{...props}向下合并传递 &lt;Route render={(props)=&gt;&lt;App {...props} x={1}/&gt;} path=&quot;/&quot; /&gt; &lt;/Router&gt;, 隐式传参代替url传参可以用来埋点分享 &lt;Link to={{ pathname: 'artical/2', state: { form: 'artical' } }}&gt;文章二&lt;/Link&gt; 埋点发送数据方法 ajax img: 兼容性最好 const img = new Image() img.src = &quot;http://...../button-01.gif?x=16....&quot; sendBeacon 兼容性不好，成功率最高 编程式导航 history.push(‘…’) export default class ArticalDetail extends Component { goHome = () =&gt; { this.props.history.push(&#39;/&#39;) } render() { console.log(this.props) return ( &lt;div&gt; 文章详情 {this.props.match.params.id} &lt;button onClick={this.goHome}&gt;返回首页&lt;/button&gt; &lt;/div&gt; ) } } this.props.history.push({对象}) goHome = () =&gt; { this.props.history.push({ pathname: &#39;/&#39;, state: { x: 1 } }) } render() { console.log(this.props) return ( &lt;div&gt; 文章详情 {this.props.match.params.id} &lt;button onClick={this.goHome}&gt;返回首页&lt;/button&gt; &lt;/div&gt; ) } withRouter 高阶组件若想要点击一个组件，触发组件内的事件并使用当前的参数，则可以使用 withRouter 高阶组件包裹 组件 export default withRouter(BackHome) Antd 蚂蚁设计 UI库 npm i antd -s 配置 Antdcreate-react-app配置 npm i react-app-rewired customize-cra -D 然后修改 page.json 然后在项目根目录创建一个 config-overrides.js 用于修改默认配置。 npm i babel-plugin-import -D使用 babel-plugin-import后修改 config-overrides.js 使用Antd自定义主题需要先安装 less less-loader 因为 Antd 样式文件使用less开发 npm i less less-loader -s const { override, fixBabelImports, addDecoratorsLegacy, addLessLoader } = require(&quot;customize-cra&quot;); module.exports = override( fixBabelImports(&quot;import&quot;, { //antd按需加载 libraryName: &quot;antd&quot;, libraryDirectory: &quot;es&quot;, style: &quot;css&quot;, style: true }), addDecoratorsLegacy(), // 配置装饰器 addLessLoader({ // Antd 自定义主题设置 javascriptEnabled: true, modifyVars: { &#39;@primary-color&#39;: &#39;#1DA57A&#39; }, }), );","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.hjiya.cn/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://blog.hjiya.cn/categories/技术/"}]},{"title":"面试题思考汇总（Node篇）","slug":"interview1","date":"2020-03-21T05:23:03.000Z","updated":"2020-03-26T04:01:34.590Z","comments":true,"path":"2020/03/21/interview1/","link":"","permalink":"http://blog.hjiya.cn/2020/03/21/interview1/","excerpt":"","text":"1. node是单线程还是多线程Node是单线程的，但Node能开启多进程 2. 那Node怎么开启多线程可以使用Node里的内置模块 Cluster 开启多进程 下面来看段代码 const cluster = require(&#39;cluster&#39;) const os = require(&#39;os&#39;) const numCPUs = os.cpus().length const process = require(&#39;process&#39;) console.log(&#39;numCPUs&#39;,numCPUs) const workers = {} if(cluster.isMaster){ cluster.on(&#39;death&#39;, function(worker){ worker = cluster.fork() workers[worker.pid] = worker }) // 主进程 for(let i=0;i&lt;numCPUs;i++){ const worker = cluster.fork() workers[worker.pid] = worker } // 当进程被终止 process.on(&#39;SIGTERM&#39;, function(){ for(let pid in workers){ process.kill(pid) } process.exit(0) }) } else { // 其他进程，工作进程 const app = require(&#39;./app&#39;) app.use(async (ctx,next) =&gt; { console.log(&#39;worker&#39; + cluster.worker.id + &#39;,PID: &#39; + process.pid) next() }) app.listen(3000,() =&gt; { console.log(&#39;http://127.0.0.1:3000&#39;) }) } 3. 这里都是监听了统一端口，他们会冲突吗？ 并不会冲突，简单的说 在服务器同时启动多个进程。 每个进程都跑的是同一份源码（好比把以前一个进程的工作分给多个进程去做） 更神奇的是，这些进程可以同时监听一个端口 其中 启动其他进程的叫做Master进程，他好比是个包工头，不做具体的工作，只负责启动其他进程 其他被Master启动的叫做Worker进程，顾名思义就是干活的工人，它们接受请求，对外提供服务 Woker进程数量一般工具服务器的CPU决定，这样就可以利用多核资源 4. 那它们是怎么调度的未完待续…","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.hjiya.cn/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://blog.hjiya.cn/categories/技术/"}]},{"title":"Birthday","slug":"birthday","date":"2020-03-21T02:47:04.000Z","updated":"2020-03-21T04:19:58.633Z","comments":true,"path":"2020/03/21/birthday/","link":"","permalink":"http://blog.hjiya.cn/2020/03/21/birthday/","excerpt":"","text":"前言闲来无事，搭个博客吧，也不知道写些啥，那就记录下我那平淡无奇的生活吧。","categories":[{"name":"随想","slug":"随想","permalink":"http://blog.hjiya.cn/categories/随想/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"http://blog.hjiya.cn/tags/悦读/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"http://blog.hjiya.cn/categories/随想/"}]}]}